{
  "clientVersions": {
    "description": "Управление требованиями версии клиента для обеспечения использования последней стабильной версии. VSCode и CLI управляются отдельно.",
    "empty": {
      "description": "过去 7 天内没有活跃用户使用可识别的客户端",
      "title": "暂无客户端数据"
    },
    "features": {
      "activeWindow": "活跃窗口：",
      "activeWindowDesc": "仅统计过去 7 天内有请求的用户",
      "autoDetect": "系统会自动检测每种客户端的最新稳定版本（GA 版本）",
      "blockOldVersion": "使用旧版本的用户将收到 HTTP 400 错误，无法继续使用服务",
      "errorMessage": "错误提示中包含当前版本和需要升级的版本号",
      "gaRule": "判定规则：",
      "gaRuleDesc": "当某个版本被 1 个以上用户使用时，视为 GA 版本",
      "recommendation": "推荐做法：",
      "recommendationDesc": "先观察下方的版本分布，确认新版本稳定后再启用。",
      "title": "功能说明",
      "whatHappens": "启用后会发生什么："
    },
    "section": {
      "distribution": {
        "description": "显示过去 7 天内活跃用户的客户端版本信息。每种客户端类型独立统计 GA 版本。",
        "title": "客户端版本分布"
      },
      "settings": {
        "description": "启用后，系统将自动检测客户端版本并拦截旧版本用户的请求。",
        "title": "升级提醒设置"
      }
    },
    "table": {
      "currentGA": "当前 GA 版本：",
      "internalType": "内部类型：",
      "lastActive": "最后活跃时间",
      "latest": "最新",
      "needsUpgrade": "需升级",
      "noUsers": "暂无用户数据",
      "status": "状态",
      "unknown": "未知",
      "user": "用户",
      "usersCount": "{count} 位用户",
      "version": "当前版本"
    },
    "title": "Напоминание об обновлении клиента",
    "toggle": {
      "description": "При включении система автоматически проверяет версию и блокирует старые версии.",
      "disableSuccess": "Проверка версии клиента отключена",
      "enable": "Включить проверку версии клиента",
      "enableSuccess": "Проверка версии клиента включена",
      "toggleFailed": "Ошибка переключения"
    }
  },
  "common": {
    "cancel": "Отменить",
    "completed": "Завершено",
    "confirm": "Подтвердить",
    "copied": "Ключ скопирован в буфер обмена",
    "copy": "Копировать",
    "copyFailed": "Ошибка копирования",
    "create": "Создать",
    "creating": "Создание...",
    "delete": "Удалить",
    "disabled": "Отключено",
    "edit": "Редактировать",
    "empty": "Результаты не найдены",
    "enabled": "Включено",
    "error": "Неизвестная ошибка",
    "failed": "Ошибка",
    "loading": "Загрузка...",
    "none": "Нет (нет пользователей с этой версией)",
    "refresh": "Обновить",
    "reset": "Сброс",
    "save": "Сохранить",
    "saving": "Сохранение...",
    "submit": "Отправить",
    "success": "Успех",
    "test": "Тестировать",
    "testing": "Тестирование...",
    "unlimited": "Без ограничений",
    "unlimited_desc": "Без ограничений",
    "update": "Обновить",
    "updating": "Обновление..."
  },
  "config": {
    "autoCleanup": "Автоматическая очистка логов",
    "autoCleanupDesc": "Автоматически очищать исторические логи по расписанию для освобождения места в БД.",
    "description": "Управление основными параметрами системы, влияющими на отображение и поведение статистики.",
    "form": {
      "allowGlobalView": "Разрешить просмотр глобального использования",
      "allowGlobalViewDesc": "При отключении обычные пользователи могут видеть только статистику использования своих ключей на панели.",
      "cleanupSchedule": "График очистки",
      "cleanupScheduleDesc": "Выбрать расписание автоматической очистки",
      "configUpdated": "Параметры системы обновлены. Страница обновится для применения изменений валюты.",
      "currencyDisplay": "Валюта",
      "currencyDisplayPlaceholder": "Выберите валюту",
      "currencyDisplayDesc": "После изменения все страницы и API будут использовать соответствующий символ валюты (только символ, без конвертации).",
      "keepDays": "Хранить дней",
      "keepDaysDesc": "Очищать логи старше указанного количества дней",
      "saveFailed": "Ошибка сохранения",
      "saveSuccess": "Сохранено успешно",
      "saveError": "Ошибка сохранения",
      "saveSettings": "Сохранить настройки",
      "siteTitle": "Название сайта",
      "siteTitlePlaceholder": "например: Claude Code Hub",
      "siteTitleRequired": "Название сайта не может быть пустым",
      "siteTitleDesc": "Используется для установки заголовка вкладки браузера и имени системы по умолчанию.",
      "enableAutoCleanup": "Включить автоочистку",
      "enableAutoCleanupDesc": "Автоматически очищать исторические логи по расписанию",
      "cleanupRetentionDays": "Хранить дней",
      "cleanupRetentionDaysRequired": "Хранить дней *",
      "cleanupRetentionDaysPlaceholder": "30",
      "cleanupRetentionDaysDesc": "Логи старше этого количества дней будут автоматически очищены (диапазон: 1-365 дней)",
      "cleanupScheduleLabel": "Время выполнения (Cron)",
      "cleanupScheduleRequired": "Время выполнения (Cron) *",
      "cleanupSchedulePlaceholder": "0 2 * * *",
      "cleanupScheduleCronDesc": "Cron-выражение, по умолчанию: 0 2 * * * (2 часа ночи ежедневно)",
      "cleanupScheduleCronExample": "Пример: 0 3 * * 0 (3 часа ночи каждое воскресенье)",
      "cleanupBatchSize": "Размер пакета",
      "cleanupBatchSizeRequired": "Размер пакета *",
      "cleanupBatchSizePlaceholder": "10000",
      "cleanupBatchSizeDesc": "Количество записей для удаления за раз (диапазон: 1000-100000, рекомендуется 10000)",
      "saveConfig": "Сохранить конфигурацию",
      "autoCleanupSaved": "Конфигурация автоочистки сохранена"
    },
    "siteSettings": "Параметры сайта",
    "siteSettingsDesc": "Настройка названия сайта, валюты и политики отображения статистики.",
    "title": "Конфигурация"
  },
  "data": {
    "cleanup": {
      "descriptionWarning": "Очистка исторических данных логов для освобождения дискового пространства базы данных. Примечание: Статистические данные будут сохранены, но детали логов будут удалены навсегда.",
      "rangeLabel": "Диапазон очистки",
      "range": {
        "7days": "Логи старше 1 недели (7 дней)",
        "30days": "Логи старше 1 месяца (30 дней)",
        "90days": "Логи старше 3 месяцев (90 дней)",
        "180days": "Логи старше 6 месяцев (180 дней)"
      },
      "rangeDescription": {
        "7days": "1 неделю назад",
        "30days": "1 месяц назад",
        "90days": "3 месяца назад",
        "180days": "6 месяцев назад",
        "default": "{days} дней назад"
      },
      "willClean": "Будут очищены все записи логов с {range}",
      "button": "Очистить логи",
      "confirmTitle": "Подтверждение очистки логов",
      "confirmWarning": "Эта операция навсегда удалит все записи логов с {range} и не может быть отменена.",
      "previewLoading": "Подсчет...",
      "previewCount": "Будет удалено {count} записей логов",
      "previewError": "Не удается получить предварительный просмотр",
      "statisticsRetained": "✓ Статистические данные будут сохранены (для анализа трендов)",
      "logsDeleted": "✗ Детали логов будут удалены (содержимое запроса/ответа, информация об ошибках и т.д.)",
      "backupRecommendation": "Рекомендация: Экспортируйте резервную копию базы данных перед очисткой на случай, если потребуется восстановление.",
      "cancel": "Отмена",
      "confirm": "Подтвердить очистку",
      "cleaning": "Очистка...",
      "successMessage": "Успешно очищено {count} записей логов ({batches} пакетов, заняло {duration}с)",
      "failed": "Очистка не удалась",
      "error": "Не удалось очистить логи"
    },
    "description": "Управление резервной копией и восстановлением БД с полным импортом/экспортом и очисткой логов.",
    "export": {
      "descriptionFull": "Экспорт полного файла резервной копии базы данных (формат .dump) для миграции или восстановления данных. Резервная копия использует формат PostgreSQL custom format, автоматически сжимается и совместима с разными версиями базы данных.",
      "button": "Экспортировать базу данных",
      "exporting": "Экспорт...",
      "successMessage": "База данных успешно экспортирована!",
      "failed": "Экспорт не удался",
      "error": "Не удалось экспортировать базу данных"
    },
    "guide": {
      "backup": "Рекомендация безопасности: перед импортом сначала экспортируйте текущую БД как резервную копию.",
      "cleanup": "Очистка логов: физически удаляет исторические логи (необратимо). Таблица статистики будет сохранена. Рекомендуется сначала экспортировать резервную копию.",
      "docker": "Требования окружения: требует развертывания Docker Compose. Локальная разработка может не поддерживаться.",
      "format": "Формат резервной копии: использует PostgreSQL custom format (.dump), автоматически сжимается и совместим с разными версиями БД.",
      "merge": "Режим объединения: сохраняет существующие данные и пытается вставить из резервной копии. Конфликты первичного ключа могут привести к ошибкам.",
      "overwrite": "Режим перезаписи: удаляет все существующие данные перед импортом. Лучше всего для полного восстановления.",
      "title": "Инструкции и меры предосторожности"
    },
    "import": {
      "descriptionFull": "Восстановление базы данных из файла резервной копии. Поддерживает файлы резервных копий в формате PostgreSQL custom format (.dump).",
      "selectFileLabel": "Выбрать файл резервной копии",
      "fileSelected": "Выбрано: {name} ({size} МБ)",
      "fileError": "Пожалуйста, выберите файл резервной копии в формате .dump",
      "noFileSelected": "Сначала выберите файл резервной копии",
      "cleanFirstLabel": "Очистить существующие данные (режим перезаписи)",
      "cleanFirstDescription": "Удалить все существующие данные перед импортом, чтобы база данных точно соответствовала резервной копии. Если не отмечено, будет предпринята попытка объединения данных, но это может не удаться из-за конфликтов первичных ключей.",
      "button": "Импортировать базу данных",
      "importing": "Импорт...",
      "progressTitle": "Прогресс импорта",
      "confirmTitle": "Подтверждение импорта базы данных",
      "confirmOverwrite": "Вы выбрали 'Режим перезаписи', который удалит все существующие данные перед импортом резервной копии.",
      "confirmMerge": "Вы выбрали 'Режим объединения', который попытается импортировать резервную копию, сохраняя существующие данные.",
      "warningOverwrite": "⚠️ Предупреждение: Это действие необратимо, все текущие данные будут навсегда удалены!",
      "warningMerge": "⚠️ Примечание: Импорт может не удаться при наличии конфликтов первичных ключей.",
      "backupFile": "Файл резервной копии:",
      "backupRecommendation": "Рекомендуется экспортировать текущую базу данных в качестве резервной копии перед продолжением.",
      "cancel": "Отмена",
      "confirm": "Подтвердить импорт",
      "successMessage": "Импорт данных завершен!",
      "failedMessage": "Импорт данных не удался, проверьте подробные логи",
      "error": "Не удалось импортировать базу данных",
      "streamError": "Не удается прочитать поток ответа",
      "errorUnknown": "Неизвестная ошибка"
    },
    "status": {
      "loading": "Загрузка...",
      "error": "Не удалось получить статус базы данных",
      "retry": "Повторить",
      "connected": "База данных подключена",
      "unavailable": "База данных недоступна",
      "tables": "{count} таблиц"
    },
    "title": "Управление данными",
    "section": {
      "status": {
        "title": "Статус базы данных",
        "description": "Просмотр текущего статуса подключения к базе данных и основной информации."
      },
      "cleanup": {
        "title": "Очистка логов",
        "description": "Очистка исторических данных логов для освобождения дискового пространства базы данных. Примечание: Статистические данные будут сохранены, но детали логов будут удалены навсегда."
      },
      "export": {
        "title": "Экспорт данных",
        "description": "Экспорт полного файла резервной копии базы данных (формат .dump) для миграции или восстановления данных."
      },
      "import": {
        "title": "Импорт данных",
        "description": "Восстановление базы данных из файла резервной копии. Поддерживает файлы резервных копий в формате PostgreSQL custom format (.dump)."
      }
    }
  },
  "errors": {
    "addFailed": "Ошибка добавления поставщика",
    "addSuccess": "Добавлено успешно",
    "deleteFailed": "Ошибка удаления поставщика",
    "deleteSuccess": "Удалено успешно",
    "editFailed": "Ошибка обновления поставщика",
    "editSuccess": "Обновлено успешно",
    "loadFailed": "Ошибка загрузки параметров уведомлений",
    "saveFailed": "Ошибка сохранения",
    "saveFailed_error": "Ошибка сохранения параметров",
    "saveSuccess": "Сохранено успешно",
    "syncFailed": "Ошибка синхронизации",
    "syncSuccess": "Синхронизация успешна",
    "testFailed": "Ошибка тестирования",
    "testFailedRetry": "Ошибка тестирования. Пожалуйста, повторите.",
    "unknownError": "Ошибка при выполнении операции"
  },
  "logs": {
    "description": "Динамическая регулировка уровня логирования для контроля подробности.",
    "subtitle": "Контроль уровня логирования",
    "subtitleDesc": "Изменения вступают в силу немедленно без перезагрузки. Полезно для отладки в производстве.",
    "section": {
      "title": "Контроль уровня логирования",
      "description": "Изменения вступают в силу немедленно без перезапуска сервиса."
    },
    "levels": {
      "fatal": {
        "label": "Fatal",
        "description": "Только критические ошибки"
      },
      "error": {
        "label": "Error",
        "description": "Сообщения об ошибках"
      },
      "warn": {
        "label": "Warn",
        "description": "Предупреждения + Ошибки"
      },
      "info": {
        "label": "Info",
        "description": "Ключевые бизнес-события + Предупреждения + Ошибки (Рекомендуется для продакшена)"
      },
      "debug": {
        "label": "Debug",
        "description": "Отладочная информация + Все уровни (Рекомендуется для разработки)"
      },
      "trace": {
        "label": "Trace",
        "description": "Очень подробная трассировка + Все уровни"
      }
    },
    "form": {
      "currentLevel": "Текущий уровень логирования",
      "selectLevel": "Выбрать уровень логирования",
      "save": "Сохранить параметры",
      "saving": "Сохранение...",
      "success": "Уровень логирования установлен: {level}",
      "failed": "Ошибка установки",
      "failedError": "Ошибка установки уровня логирования",
      "fetchFailed": "Ошибка получения уровня логирования",
      "effectiveImmediately": "Изменения уровня логирования вступают в силу немедленно без перезапуска сервиса.",
      "levelGuideTitle": "Руководство по уровням логирования",
      "levelGuideFatal": "Fatal/Error: Показывать только ошибки, минимальное логирование, подходит для высоконагруженного продакшена",
      "levelGuideWarn": "Warn: Включает предупреждения (ограничение скорости, открытие автомата защиты и т.д.) + Ошибки",
      "levelGuideInfo": "Info (Рекомендуется для продакшена): Показывает ключевые бизнес-события (выбор поставщика, повторное использование сессии, синхронизация цен) + Предупреждения + Ошибки",
      "levelGuideDebug": "Debug (Рекомендуется для разработки): Включает подробную отладочную информацию, подходит для устранения проблем",
      "levelGuideTrace": "Trace: Очень подробная трассировочная информация, включает все детали",
      "changeNotice": "Текущий уровень {current}, после сохранения переключится на {selected}"
    },
    "title": "Управление логами"
  },
  "nav": {
    "apiDocs": "API документация",
    "clientVersions": "Напоминание об обновлении",
    "config": "Конфигурация",
    "data": "Управление данными",
    "logs": "Логи",
    "notifications": "Уведомления",
    "prices": "Прайс-лист",
    "providers": "Поставщики",
    "sensitiveWords": "Чувствительные слова"
  },
  "notifications": {
    "circuitBreaker": {
      "description": "Немедленно отправить оповещение когда поставщик полностью замкнут",
      "enable": "Включить оповещение автоматического выключателя",
      "test": "Проверить соединение",
      "title": "Оповещение автоматического выключателя",
      "webhook": "URL Webhook",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=..."
    },
    "costAlert": {
      "description": "Отправить оповещение когда расходы превышают порог квоты",
      "enable": "Включить оповещение о стоимости",
      "interval": "Интервал проверки (минуты)",
      "test": "Проверить соединение",
      "threshold": "Порог оповещения",
      "thresholdHelp": "Оповестить когда расходы достигают {percent}% квоты",
      "thresholdLabel": "Порог оповещения: {percent}%",
      "title": "Оповещение о стоимости",
      "webhook": "URL Webhook",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=..."
    },
    "dailyLeaderboard": {
      "description": "Отправлять ежедневно рейтинг Top N пользователей по расходам",
      "enable": "Включить ежедневный рейтинг",
      "test": "Проверить соединение",
      "time": "Время отправки",
      "timeError": "Ошибка формата времени, должно быть HH:mm",
      "timePlaceholder": "09:00",
      "title": "Ежедневный рейтинг расходов",
      "topN": "Показать Top N",
      "webhook": "URL Webhook",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=..."
    },
    "description": "Настройка отправки уведомлений через робота WeChat Work",
    "form": {
      "loadError": "Ошибка загрузки параметров уведомлений",
      "loading": "Загрузка...",
      "save": "Сохранить параметры",
      "saveError": "Ошибка сохранения параметров",
      "saveFailed": "Ошибка сохранения",
      "saving": "Сохранение...",
      "success": "Параметры уведомлений сохранены и перепланы переданы",
      "testError": "Ошибка проверки соединения",
      "testFailed": "Ошибка тестирования",
      "testFailedRetry": "Ошибка тестирования. Пожалуйста, повторите.",
      "testNoResult": "Тестирование успешно но результат не возвращен",
      "testSuccess": "Тестовое сообщение отправлено. Проверьте WeChat Work.",
      "webhookRequired": "Пожалуйста, сначала заполните URL Webhook"
    },
    "global": {
      "description": "Включить или отключить все функции отправки уведомлений",
      "enable": "Включить отправку уведомлений",
      "title": "Главный переключатель уведомлений"
    },
    "title": "Отправка уведомлений"
  },
  "prices": {
    "description": "Управление конфигурацией платформы и ценами моделей",
    "dialog": {
      "description": "Загрузить JSON файл для обновления прайс-листа",
      "fileSizeLimit": "Размер файла не может превышать 10MB",
      "fileSizeLimitSmall": "Размер файла не превышает 10MB",
      "getError": "Ошибка получения ключа",
      "readError": "Ошибка получения ключа",
      "selectFile": "Нажмите для выбора JSON или перетащите сюда",
      "title": "Обновить прайс-лист",
      "upload": "Загрузить",
      "uploading": "Загрузка..."
    },
    "noData": "Система имеет встроенный прайс-лист. Используйте кнопки выше для синхронизации.",
    "noModels": "Цены моделей не найдены",
    "search": "搜索模型名称...",
    "subtitle": "Цены моделей",
    "subtitleDesc": "Управление ценами AI моделей",
    "sync": "同步 LiteLLM 价格",
    "syncFailed": "Ошибка синхронизации",
    "syncFailedError": "Ошибка синхронизации:",
    "syncNoResult": "Прайс-лист обновлен но результат не возвращен",
    "syncSuccess": "Прайс-лист обновлен успешно",
    "syncing": "Синхронизация...",
    "table": {
      "cachePrice": "缓存价格",
      "inputPrice": "Цена ввода ($/M)",
      "model": "模型",
      "outputPrice": "Цена вывода ($/M)",
      "updatedAt": "Обновлено"
    },
    "title": "Прайс-лист",
    "upload": "更新模型价格表",
    "uploadFailed": "Ошибка получения данных о ценах:",
    "uploadSuccess": "Прайс-лист обновлен успешно"
  },
  "providers": {
    "add": "Добавить поставщика",
    "addFailed": "Ошибка добавления поставщика",
    "addProvider": "新增服务商",
    "addSuccess": "Поставщик добавлен успешно",
    "circuitBroken": "熔断中",
    "clone": "Дублировать поставщика",
    "cloneFailed": "Ошибка копирования",
    "confirmDelete": "Вы уверены, что хотите удалить этого поставщика?",
    "confirmDeleteDesc": "确定要删除供应商 \"{name}\" 吗？此操作无法撤销。",
    "confirmDeleteProvider": "确认删除供应商？",
    "confirmDeleteProviderDesc": "确定要删除服务商\"{name}\"吗？此操作不可恢复。",
    "createProvider": "新增服务商",
    "delete": "Удалить поставщика",
    "deleteFailed": "Ошибка удаления поставщика",
    "deleteSuccess": "删除成功",
    "description": "Настройка поставщиков API и контроль статуса доступности.",
    "disabledStatus": "禁用",
    "displayCount": "显示 {filtered} / {total} 个供应商",
    "edit": "Редактировать поставщика",
    "editFailed": "Ошибка обновления поставщика",
    "editProvider": "编辑服务商",
    "enabledStatus": "启用",
    "form": {
      "addRedirect": "Добавить переправку",
      "allowAllModels": "✓ Разрешить все модели (рекомендуется)",
      "apiAddress": "API 地址",
      "apiAddressPlaceholder": "例如: https://open.bigmodel.cn/api/anthropic",
      "apiAddressRequired": "API 地址 *",
      "apiKey": "API ключ",
      "apiKeyCurrent": "当前密钥:",
      "apiKeyLeaveEmpty": "（留空不更改）",
      "apiKeyLeaveEmptyDesc": "留空则不更改密钥",
      "apiKeyOptional": "Оставьте пустым, чтобы оставить текущий ключ",
      "apiKeyPlaceholder": "Введите API ключ",
      "apiKeyRequired": "API 密钥 *",
      "baseUrl": "Базовый URL",
      "baseUrlPlaceholder": "например: https://open.bigmodel.cn/api/anthropic",
      "baseUrlRequired": "Пожалуйста, сначала заполните URL поставщика",
      "circuitBreakerConfig": "熔断器配置",
      "circuitBreakerConfigSummary": "{failureThreshold} 次失败 / {openDuration} 分钟熔断 / {successThreshold} 次成功恢复",
      "circuitBreakerDesc": "供应商连续失败时自动熔断，避免影响整体服务质量",
      "clearSearch": "Очистить поиск",
      "codexInstructions": "Политика инструкций Codex",
      "codexInstructionsAuto": "Автоматически (рекомендуется)",
      "codexInstructionsDesc": "(определяет политику планирования)",
      "codexInstructionsForce": "Принудительно официальные",
      "codexInstructionsKeep": "Сохранить оригинал",
      "codexStrategyAutoDesc": "透传客户端 instructions，400 错误时自动重试官方 prompt",
      "codexStrategyAutoLabel": "自动 (推荐)",
      "codexStrategyConfig": "Codex Instructions 策略",
      "codexStrategyConfigAuto": "自动 (推荐)",
      "codexStrategyConfigForce": "强制官方",
      "codexStrategyConfigKeep": "透传原样",
      "codexStrategyDesc": "控制如何处理 Codex 请求的 instructions 字段，影响与上游中转站的兼容性",
      "codexStrategyForceDesc": "始终使用官方 Codex CLI instructions（约 4000+ 字）",
      "codexStrategyForceLabel": "强制官方",
      "codexStrategyHint": "提示: 部分严格的 Codex 中转站（如 88code、foxcode）需要官方 instructions，选择\"自动\"或\"强制官方\"策略",
      "codexStrategyKeepDesc": "始终透传客户端 instructions，不自动重试（适用于宽松中转站）",
      "codexStrategyKeepLabel": "透传原样",
      "codexStrategySelect": "策略选择",
      "collapseAll": "折叠全部高级配置",
      "confirmAdd": "确认添加",
      "confirmAddPending": "添加中...",
      "confirmUpdate": "确认更新",
      "confirmUpdatePending": "更新中...",
      "costMultiplier": "Множитель стоимости",
      "costMultiplierDesc": "например: A (стоимость 1.0x), C (стоимость 0.8x)",
      "costMultiplierLabel": "成本倍率",
      "costMultiplierPlaceholder": "1.0",
      "deleteButton": "删除",
      "enabled": "Включено",
      "expandAll": "展开全部高级配置",
      "failureThreshold": "失败阈值（次）",
      "failureThresholdDesc": "连续失败多少次后触发熔断",
      "failureThresholdPlaceholder": "5",
      "filterAllProviders": "全部供应商",
      "filterByType": "Фильтр по типу",
      "filterProvider": "筛选供应商类型",
      "group": "Группа",
      "groupPlaceholder": "например: premium, economy",
      "joinClaudePool": "加入 Claude 调度池",
      "joinClaudePoolDesc": "启用后，此供应商将与 Claude 类型供应商一起参与负载均衡调度",
      "joinClaudePoolHelp": "仅当模型重定向配置中存在映射到 claude-* 模型时可用。启用后，当用户请求 claude-* 模型时，此供应商也会参与调度选择。",
      "leaveEmpty": "Оставьте пустым для неограниченного доступа",
      "limit0Means": "0 означает без ограничений",
      "limit5hLabel": "5小时消费上限 (USD)",
      "limitAmount5h": "Лимит расходов за 5 часов (USD)",
      "limitAmount5hDesc": "например: Поставщик B имеет лимит $10, уже потрачено $9.8",
      "limitAmountMonthly": "Месячный лимит расходов (USD)",
      "limitAmountWeekly": "Недельный лимит расходов (USD)",
      "limitConcurrent": "Лимит параллельных сеансов",
      "limitConcurrentDesc": "например: Поставщик C имеет лимит 2, в данный момент 2 активных сеанса",
      "limitConcurrentLabel": "并发 Session 上限",
      "limitMonthlyLabel": "月消费上限 (USD)",
      "limitPlaceholder0": "0 表示无限制",
      "limitPlaceholderUnlimited": "留空表示无限制",
      "limitWeeklyLabel": "周消费上限 (USD)",
      "modelRedirects": "Перенаправление моделей",
      "modelRedirectsAddNew": "添加新规则",
      "modelRedirectsCurrentRules": "当前规则 ({count})",
      "modelRedirectsDesc": "Переправить запросы Claude к другим поддерживаемым моделям",
      "modelRedirectsEmpty": "暂无重定向规则。添加规则后，系统将自动重写请求中的模型名称。",
      "modelRedirectsExists": "模型 \"{model}\" 已存在重定向规则",
      "modelRedirectsLabel": "模型重定向配置",
      "modelRedirectsOptional": "(可选)",
      "modelRedirectsSourceModel": "用户请求的模型",
      "modelRedirectsSourcePlaceholder": "例如: claude-sonnet-4-5-20250929",
      "modelRedirectsSourceRequired": "源模型名称不能为空",
      "modelRedirectsTargetModel": "实际转发的模型",
      "modelRedirectsTargetPlaceholder": "例如: glm-4.6",
      "modelRedirectsTargetRequired": "目标模型名称不能为空",
      "modelWhitelist": "模型白名单",
      "modelWhitelistAllowAll": "允许所有 {type} 模型",
      "modelWhitelistAllowAllClause": "允许所有 Claude 模型",
      "modelWhitelistAllowAllOpenAI": "允许所有 OpenAI 模型",
      "modelWhitelistClear": "清空",
      "modelWhitelistDesc": "限制此供应商可以处理的模型。默认情况下，供应商可以处理该类型下的所有模型。",
      "modelWhitelistLabel": "允许的模型",
      "modelWhitelistLoading": "加载中...",
      "modelWhitelistManualAdd": "手动添加模型",
      "modelWhitelistManualDesc": "支持添加任意模型名称（不限于价格表中的模型）",
      "modelWhitelistManualPlaceholder": "输入模型名称（如 gpt-5-turbo）",
      "modelWhitelistNotFound": "未找到模型",
      "modelWhitelistSearchPlaceholder": "搜索模型名称...",
      "modelWhitelistSelectAll": "全选 ({count})",
      "modelWhitelistSelected": "已选择 {count} 个模型",
      "modelWhitelistSelectedOnly": "仅允许选中的 {count} 个模型。其他模型的请求不会调度到此供应商。",
      "name": "Имя",
      "namePlaceholder": "Введите имя поставщика",
      "openDuration": "熔断时长（分钟）",
      "openDurationDesc": "熔断后多久自动进入半开状态",
      "openDurationPlaceholder": "30",
      "priority": "Приоритет",
      "priorityDesc": "В пределах одного приоритета сортировка по множителю стоимости от низкого к высокому",
      "priorityLabel": "优先级",
      "priorityPlaceholder": "0",
      "providerGroupDesc": "供应商分组标签。只有用户的 providerGroup 与此值匹配时，该用户才能使用此供应商。示例：设置为 \"premium\" 表示只供 providerGroup=\"premium\" 的用户使用",
      "providerGroupLabel": "供应商分组",
      "providerGroupPlaceholder": "例如: premium, economy",
      "providerName": "服务商名称",
      "providerNamePlaceholder": "例如: 智谱",
      "providerNameRequired": "服务商名称 *",
      "providerType": "Тип поставщика",
      "providerTypeDesc": "选择供应商的 API 格式类型。",
      "providerTypeDisabledNote": "注：Gemini CLI 和 OpenAI Compatible 类型功能正在开发中，暂不可用",
      "proxy": "Прокси",
      "proxyAddressFormats": "支持格式:",
      "proxyAddressLabel": "代理地址",
      "proxyAddressOptional": "(可选)",
      "proxyAddressPlaceholder": "例如: http://proxy.example.com:8080 或 socks5://127.0.0.1:1080",
      "proxyConfig": "代理配置",
      "proxyConfigDesc": "配置代理服务器以改善供应商连接性（支持 HTTP、HTTPS、SOCKS4、SOCKS5）",
      "proxyConfigNone": "未配置",
      "proxyConfigSummary": "已配置代理",
      "proxyConfigSummaryFallback": " (启用降级)",
      "proxyConfigured": "Прокси настроен",
      "proxyFallback": "Откат при ошибке прокси",
      "proxyFallbackDesc": "Перейти на прямое соединение при ошибке прокси",
      "proxyFallbackLabel": "代理失败时降级到直连",
      "proxyNotConfigured": "Не настроен",
      "proxyTestButton": "测试连接",
      "proxyTestDesc": "测试通过配置的代理访问供应商 URL（使用 HEAD 请求，不消耗额度）",
      "proxyTestFailed": "连接失败",
      "proxyTestFillUrl": "请先填写供应商 URL",
      "proxyTestLabel": "连接测试",
      "proxyTestNetworkError": "网络错误: {error}",
      "proxyTestProxyError": "代理错误: {error}",
      "proxyTestResponseTime": "响应时间: {time}",
      "proxyTestResultConnectionMethod": "连接方式: {via}",
      "proxyTestResultConnectionMethodDirect": "直连",
      "proxyTestResultConnectionMethodProxy": "代理",
      "proxyTestResultErrorType": "错误类型: {type}",
      "proxyTestResultFailed": "连接失败",
      "proxyTestResultMessage": "{message}",
      "proxyTestResultResponseTime": "响应时间: {time}ms",
      "proxyTestResultStatusCode": "状态码: {code}",
      "proxyTestResultSuccess": "连接成功 {via}",
      "proxyTestStatusCode": "| 状态码: {code}",
      "proxyTestSuccess": "连接成功",
      "proxyTestTesting": "测试中...",
      "proxyTestTimeout": "连接超时（5秒）。请检查：\n1. 代理服务器是否可访问\n2. 代理地址和端口是否正确\n3. 代理认证信息是否正确",
      "proxyTestViaDirect": "（直连）",
      "proxyTestViaProxy": "（通过代理）",
      "proxyUrl": "Адрес прокси",
      "proxyUrlPlaceholder": "например: http://proxy.example.com:8080 или socks5://127.0.0.1:1080",
      "rateLimitConfig": "限流配置",
      "rateLimitConfigNone": "无限制",
      "rateLimitConfigSummary": "5h: ${fiveHour}, 周: ${weekly}, 月: ${monthly}, 并发: {concurrent}",
      "remark": "Примечание",
      "remarkPlaceholder": "Необязательно: добавить примечание...",
      "removeRedirect": "Удалить переправку",
      "routingConfig": "路由配置",
      "routingConfigNone": "未配置",
      "routingConfigSummary": "{models} 个模型白名单, {redirects} 个重定向",
      "scheduleParams": "调度参数",
      "searchClear": "清除搜索",
      "searchPlaceholder": "Поиск по имени, URL, примечанию...",
      "selectProviderType": "Выбрать тип поставщика",
      "sort": "Сортировать поставщиков",
      "sortByCost": "По стоимости",
      "sortByCreated": "По дате создания (новое-старое)",
      "sortByName": "По имени (A-Z)",
      "sortByPriority": "По приоритету (высокое-низкое)",
      "sortByWeight": "По весу (высокое-низкое)",
      "sourceModel": "Исходная модель",
      "sourceModelPlaceholder": "например: claude-sonnet-4-5-20250929",
      "sourceModelRequired": "Имя исходной модели не может быть пустым",
      "successThreshold": "恢复阈值（次）",
      "successThresholdDesc": "半开状态下成功多少次后完全恢复",
      "successThresholdPlaceholder": "2",
      "targetModel": "Целевая модель",
      "targetModelPlaceholder": "например: glm-4.6",
      "targetModelRequired": "Имя целевой модели не может быть пустым",
      "testProxy": "Проверить соединение",
      "testProxyFailed": "Ошибка тестирования прокси",
      "testProxyFailedError": "Ошибка проверки соединения:",
      "testProxySuccess": "Соединение прокси успешно",
      "validUrlRequired": "请输入有效的 API 地址",
      "websiteUrl": "供应商官网地址",
      "websiteUrlDesc": "供应商官网地址，用于快速跳转管理",
      "websiteUrlInvalid": "请输入有效的供应商官网地址",
      "websiteUrlPlaceholder": "https://example.com",
      "weight": "Вес",
      "weightDesc": "Взвешенная случайная вероятность. В пределах одного приоритета большее число означает выше вероятность выбора.",
      "weightLabel": "权重",
      "weightPlaceholder": "1"
    },
    "guide": {
      "after": "过滤后：",
      "before": "过滤前：",
      "bestPracticesConcurrent": "• 并发控制：根据供应商 API 限制设置 Session 并发数",
      "bestPracticesCost": "• 成本倍率：官方倍率为 1.0，自建服务可设置为 0.8-1.2",
      "bestPracticesLimit": "• 限额设置：根据预算设置 5 小时、7 天、30 天限额",
      "bestPracticesPriority": "• 优先级设置：核心供应商设为 0，备用供应商设为 1-3",
      "bestPracticesTitle": "最佳实践建议",
      "bestPracticesWeight": "• 权重配置：根据供应商容量设置权重（容量大 = 权重高）",
      "circuitBreaker": "Проверка автоматического выключателя",
      "circuitBreakerOpen": "A отфильтрован, осталось: B, C, D",
      "circuitBreakerRecovery": "A автоматически восстанавливается в полуоткрытое после 60 секунд",
      "circuitBreakerRecovery5h": "Автоматическое восстановление после 5-часового скользящего окна",
      "costOptimize": "2️⃣ 成本优化：同优先级内，成本倍率低的供应商有更高概率",
      "costSort": "Откат по стоимости",
      "costSortExample": "Все поставщики: A (default), B (premium), C (premium), D (economy)",
      "costSortProb": "Более дешевый C имеет более высокую вероятность выбора",
      "costSortResult": "После сортировки: C (0.8x), A (1.0x)",
      "decision": "决策：",
      "group": "Фильтрация групп пользователей",
      "groupDesc": "Если пользователь указал группу поставщиков, система приоритизирует выбор из этой группы",
      "groupDowngrade": "Записать предупреждение и выбрать из глобального пула",
      "groupExample": "Пользователь настроил providerGroup = 'premium'",
      "groupFallback": "Если в группе нет доступных поставщиков, откат на всех поставщиков",
      "groupFiltered": "Выбрать только из A и C, B и D отфильтрованы",
      "groupUnavailable": "Все поставщики в группе 'vip' отключены или превышены",
      "health": "Фильтрация здоровья (автоматический выключатель + ограничение)",
      "healthCheck": "Проверить, включен ли B и работоспособен",
      "healthCheckAmountLimit": "Проверить превышение лимитов (5ч, 7д, 30д)",
      "healthCheckAmountLimitExample": "Лимит поставщика B $10 (5ч), потрачено $9.8",
      "healthCheckCircuit": "Поставщик A потерпел неудачу 5 раз, статус: открыт",
      "healthCheckConcurrent": "Проверить количество активных сеансов на лимит",
      "healthCheckConcurrentExample": "Лимит поставщика C 2, активных 2 сеанса",
      "healthFilter": "3️⃣ 健康过滤：自动跳过熔断或超限的供应商",
      "healthFiltered": "B отфильтрован (близко к лимиту), осталось: C, D",
      "healthFiltered2": "C отфильтрован (полный), осталось: D",
      "history": "Проверить историю запросов",
      "historyDesc": "Запрос поставщиков, используемых этим ключом за последние 10 секунд",
      "priority": "Приоритизация по уровням",
      "priorityExample": "4 включенных поставщика с разными приоритетами",
      "priorityFirst": "1️⃣ 优先级优先：只从最高优先级（数值最小）的供应商中选择",
      "priorityResult": "Отфильтровано к приоритету (0): A, C",
      "priorityStep": "Система сначала фильтрует по приоритету, выбирая только из поставщиков с наивысшим приоритетом",
      "randomResult": "В конце выбран C",
      "randomSelect": "Взвешенный случайный",
      "reset": "Ручной сброс автоматического выключателя",
      "resetSuccess": "Автоматический выключатель сброшен",
      "scenario1Desc": "系统首先按优先级过滤，只从最高优先级的供应商中选择",
      "scenario1Step1": "初始状态",
      "scenario1Step1After": "筛选出最高优先级（0）的供应商：A, C",
      "scenario1Step1Before": "供应商 A (优先级 0), B (优先级 1), C (优先级 0), D (优先级 2)",
      "scenario1Step1Decision": "只从 A 和 C 中选择，B 和 D 被过滤",
      "scenario1Step1Desc": "有 4 个已启用的供应商，优先级各不相同",
      "scenario1Step2": "成本排序",
      "scenario1Step2After": "排序后：C (0.8x), A (1.0x)",
      "scenario1Step2Before": "A (成本 1.0x), C (成本 0.8x)",
      "scenario1Step2Decision": "成本更低的 C 有更高的被选中概率",
      "scenario1Step2Desc": "在同优先级内，按成本倍率从低到高排序",
      "scenario1Step3": "加权随机",
      "scenario1Step3After": "C 被选中概率 75%, A 被选中概率 25%",
      "scenario1Step3Before": "C (权重 3), A (权重 1)",
      "scenario1Step3Decision": "最终随机选择了 C",
      "scenario1Step3Desc": "使用权重进行随机选择，权重越高被选中概率越大",
      "scenario1Title": "优先级分层选择",
      "scenario2Desc": "如果用户指定了供应商组，系统会优先从该组中选择",
      "scenario2Step1": "检查用户分组",
      "scenario2Step1After": "过滤出 'premium' 组：B, C",
      "scenario2Step1Before": "所有供应商：A (default), B (premium), C (premium), D (economy)",
      "scenario2Step1Decision": "只从 B 和 C 中选择",
      "scenario2Step1Desc": "用户配置了 providerGroup = 'premium'",
      "scenario2Step2": "分组降级",
      "scenario2Step2After": "降级到所有启用的供应商：A, B, C, D",
      "scenario2Step2Before": "用户组 'vip' 内的供应商全部禁用或超限",
      "scenario2Step2Decision": "记录警告并从全局供应商池中选择",
      "scenario2Step2Desc": "如果用户组内没有可用供应商，降级到所有供应商",
      "scenario2Title": "用户分组过滤",
      "scenario3Desc": "系统自动过滤掉熔断或超限的供应商",
      "scenario3Step1": "熔断器检查",
      "scenario3Step1After": "A 被过滤，剩余：B, C, D",
      "scenario3Step1Before": "供应商 A 连续失败 5 次，熔断器状态：open",
      "scenario3Step1Decision": "A 在 60 秒后自动恢复到半开状态",
      "scenario3Step1Desc": "连续失败 5 次后熔断器打开，60 秒内不可用",
      "scenario3Step2": "金额限流",
      "scenario3Step2After": "B 被过滤（接近限额），剩余：C, D",
      "scenario3Step2Before": "供应商 B 的 5 小时限额 $10，已消耗 $9.8",
      "scenario3Step2Decision": "5 小时窗口滑动后自动恢复",
      "scenario3Step2Desc": "检查 5 小时、7 天、30 天的消费额度是否超限",
      "scenario3Step3": "并发 Session 限制",
      "scenario3Step3After": "C 被过滤（已满），剩余：D",
      "scenario3Step3Before": "供应商 C 并发限制 2，当前活跃 Session 数：2",
      "scenario3Step3Decision": "Session 过期（5 分钟）后自动释放",
      "scenario3Step3Desc": "检查当前活跃 Session 数是否超过配置的并发限制",
      "scenario3Title": "健康度过滤（熔断器 + 限流）",
      "scenario4Desc": "连续对话优先使用同一供应商，利用 Claude 的上下文缓存",
      "scenario4Step1": "检查历史请求",
      "scenario4Step1After": "检查 B 是否启用且健康",
      "scenario4Step1Before": "最近一次请求使用了供应商 B",
      "scenario4Step1Decision": "B 可用，直接复用，跳过随机选择",
      "scenario4Step1Desc": "查询该 API Key 最近 10 秒内使用的供应商",
      "scenario4Step2": "复用失效",
      "scenario4Step2After": "进入正常选择流程",
      "scenario4Step2Before": "上次使用的供应商 B 已被禁用或熔断",
      "scenario4Step2Decision": "从其他可用供应商中选择",
      "scenario4Step2Desc": "如果上次使用的供应商不可用，则重新选择",
      "scenario4Title": "会话复用机制",
      "scenariosTitle": "交互式场景演示",
      "session": "Механизм переиспользования сеансов",
      "sessionDesc": "Если последний использованный поставщик недоступен, переходим к переполнению",
      "sessionExample": "Последний запрос использовал поставщика B",
      "sessionExpired": "Сеанс автоматически освобождается после истечения (5 минут)",
      "sessionFallback": "Выбрать из других доступных поставщиков",
      "sessionLastUsed": "B доступен, переиспользуем, пропускаем случайный выбор",
      "sessionReuse": "4️⃣ 会话复用：连续对话复用同一供应商，节省上下文成本",
      "sessionUnavailable": "Последний использованный поставщик B отключен или замкнут",
      "step": "步骤",
      "title": "核心原则",
      "weight": "Взвешенный случайный выбор по весу",
      "weightCalc": "C имеет вероятность 75%, A имеет вероятность 25%",
      "weightExample": "C (вес 3), A (вес 1)"
    },
    "keyLoading": "加载中...",
    "noProviders": "暂无服务商配置",
    "noProvidersDesc": "添加你的第一个 API 服务商",
    "notFound": "Поставщики не найдены",
    "official": "官网",
    "resetCircuit": "熔断器已重置",
    "resetCircuitDesc": "供应商 \"{name}\" 的熔断状态已解除",
    "resetCircuitFailed": "重置熔断器失败",
    "scheduling": "Подробное объяснение политики планирования",
    "schedulingDesc": "Понимание того, как работает выбор поставщика: приоритизация, переиспользование сеансов, балансировка нагрузки и отказоустойчивость",
    "searchNoResults": "未找到匹配的供应商",
    "searchResults": "找到 {count} 个匹配的供应商",
    "section": {
      "description": "配置上游服务商的金额限流和并发限制，留空表示无限制。",
      "title": "服务商管理"
    },
    "subtitle": "Управление поставщиками",
    "subtitleDesc": "Настройка ограничений по расходам и параллельным сеансам. Оставьте пустым для неограниченного доступа.",
    "title": "Управление поставщиками",
    "todayUsage": "今日用量",
    "todayUsageCount": "{count} 次",
    "toggleFailed": "状态切换失败",
    "toggleSuccess": "供应商已{status}",
    "toggleSuccessDesc": "供应商 \"{name}\" 状态已更新",
    "updateFailed": "更新服务商失败",
    "viewKey": "查看完整 API Key",
    "viewKeyDesc": "请妥善保管，不要泄露给他人"
  },
  "sensitiveWords": {
    "add": "Добавить чувствительное слово",
    "addFailed": "Ошибка создания чувствительного слова",
    "addSuccess": "Чувствительное слово создано успешно",
    "cacheStats": "Статистика кэша: Содержит({containsCount}) Точное({exactCount}) Регулярное({regexCount})",
    "confirmDelete": "Вы уверены, что хотите удалить чувствительное слово \"{word}\"?",
    "delete": "Удалить чувствительное слово",
    "deleteFailed": "Ошибка удаления",
    "deleteSuccess": "Чувствительное слово удалено успешно",
    "description": "Настройка фильтрации чувствительных слов для блокирования чувствительного контента.",
    "dialog": {
      "addDescription": "Настройте правила фильтрации чувствительных слов. Совпадающие запросы не будут пересылаться.",
      "addTitle": "Добавить чувствительное слово",
      "creating": "Создание...",
      "descriptionLabel": "Описание",
      "descriptionPlaceholder": "Необязательно: Добавить описание...",
      "editDescription": "Изменить конфигурацию чувствительного слова. Изменения автоматически обновят кэш.",
      "editTitle": "Редактировать чувствительное слово",
      "matchTypeContains": "Частичное совпадение - Блокировать, если текст содержит это слово",
      "matchTypeExact": "Точное совпадение - Блокировать только при точном совпадении",
      "matchTypeLabel": "Тип совпадения *",
      "matchTypeRegex": "Регулярное выражение - Поддержка сложного сопоставления шаблонов",
      "saving": "Сохранение...",
      "wordLabel": "Чувствительное слово *",
      "wordPlaceholder": "Введите чувствительное слово...",
      "wordRequired": "Пожалуйста, введите чувствительное слово"
    },
    "disable": "Чувствительное слово отключено",
    "edit": "Редактировать чувствительное слово",
    "editFailed": "Ошибка обновления чувствительного слова",
    "editSuccess": "Чувствительное слово обновлено успешно",
    "emptyState": "Пока нет чувствительных слов. Нажмите 'Добавить чувствительное слово' в правом верхнем углу для начала настройки.",
    "enable": "Чувствительное слово включено",
    "refreshCache": "Обновить кэш",
    "refreshCacheFailed": "Не удалось обновить кэш",
    "refreshCacheSuccess": "Кэш успешно обновлен, загружено {count} чувствительных слов",
    "section": {
      "description": "Запросы, заблокированные чувствительными словами, не будут пересылаться и не будут тарифицироваться. Поддерживает частичное совпадение, точное совпадение и регулярные выражения.",
      "title": "Список чувствительных слов"
    },
    "table": {
      "actions": "Действия",
      "createdAt": "Создано",
      "description": "Описание",
      "matchType": "Тип совпадения",
      "matchTypeContains": "Частичное",
      "matchTypeExact": "Точное",
      "matchTypeRegex": "Регулярное",
      "status": "Статус",
      "word": "Чувствительное слово"
    },
    "title": "Управление чувствительными словами",
    "toggleFailed": "Ошибка переключения",
    "toggleFailedError": "Ошибка переключения:"
  },
  "notifications": {
    "title": "Push-уведомления",
    "description": "Настройка push-уведомлений робота WeChat Work",
    "global": {
      "title": "Главный переключатель уведомлений",
      "description": "Включить или отключить все функции push-уведомлений",
      "enable": "Включить push-уведомления"
    },
    "circuitBreaker": {
      "title": "Оповещение о размыкателе цепи",
      "description": "Отправить оповещение немедленно при полном размыкании провайдера",
      "enable": "Включить оповещение о размыкателе цепи",
      "webhook": "Webhook URL",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=...",
      "test": "Тест подключения"
    },
    "dailyLeaderboard": {
      "title": "Ежедневный рейтинг потребления пользователей",
      "description": "Ежедневная отправка рейтинга топ N пользователей по потреблению",
      "enable": "Включить ежедневный рейтинг",
      "webhook": "Webhook URL",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=...",
      "time": "Время отправки",
      "timePlaceholder": "09:00",
      "timeError": "Ошибка формата времени, должен быть HH:mm",
      "topN": "Показать топ N",
      "test": "Тест подключения"
    },
    "costAlert": {
      "title": "Оповещение о расходах",
      "description": "Триггер оповещения при превышении порога квоты потребления пользователя/провайдера",
      "enable": "Включить оповещение о расходах",
      "webhook": "Webhook URL",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=...",
      "threshold": "Порог оповещения",
      "thresholdLabel": "Порог оповещения: {percent}%",
      "thresholdHelp": "Оповещение при достижении {percent}% квоты",
      "interval": "Интервал проверки (минуты)",
      "test": "Тест подключения"
    },
    "form": {
      "save": "Сохранить настройки",
      "saving": "Сохранение...",
      "loading": "Загрузка...",
      "success": "Настройки уведомлений сохранены и задачи перепланированы",
      "saveFailed": "Ошибка сохранения",
      "saveError": "Не удалось сохранить настройки",
      "loadError": "Не удалось загрузить настройки уведомлений",
      "webhookRequired": "Сначала заполните Webhook URL",
      "testSuccess": "Тестовое сообщение отправлено, проверьте WeChat Work",
      "testFailed": "Тест не пройден",
      "testFailedRetry": "Тест не пройден, попробуйте снова",
      "testError": "Ошибка тестирования подключения",
      "testNoResult": "Тест пройден, но результат не возвращен"
    }
  },
  "errors": {
    "saveSuccess": "Сохранение успешно",
    "saveFailed": "Ошибка сохранения",
    "saveFailed_error": "Не удалось сохранить настройки",
    "addSuccess": "Добавление успешно",
    "addFailed": "Не удалось добавить провайдера",
    "editSuccess": "Обновление успешно",
    "editFailed": "Не удалось обновить провайдера",
    "deleteSuccess": "Удаление успешно",
    "deleteFailed": "Не удалось удалить провайдера",
    "syncSuccess": "Синхронизация успешна",
    "syncFailed": "Ошибка синхронизации",
    "testFailed": "Тест не пройден",
    "testFailedRetry": "Тест не пройден, попробуйте снова",
    "loadFailed": "Не удалось загрузить настройки уведомлений",
    "unknownError": "Во время операции произошло исключение"
  }
}
