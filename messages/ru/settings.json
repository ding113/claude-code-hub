{
  "clientVersions": {
    "description": "Управление требованиями версии клиента для обеспечения использования последней стабильной версии. VSCode и CLI управляются отдельно.",
    "empty": {
      "description": "За последние 7 дней не было активных пользователей с распознаваемыми клиентами",
      "title": "Нет данных о клиентах"
    },
    "features": {
      "activeWindow": "Активное окно:",
      "activeWindowDesc": "Учитываются только пользователи с запросами за последние 7 дней",
      "autoDetect": "Система автоматически определяет последнюю стабильную версию (GA версию) каждого типа клиента",
      "blockOldVersion": "Пользователи старых версий будут получать HTTP 400 ошибку и не смогут продолжить использование сервиса",
      "errorMessage": "Сообщение об ошибке будет содержать текущую версию и требуемую версию для обновления",
      "gaRule": "Правила определения:",
      "gaRuleDesc": "Версия считается GA версией, когда её используют более 1 пользователя",
      "recommendation": "Рекомендуемый подход:",
      "recommendationDesc": "Сначала изучите распределение версий ниже, убедитесь в стабильности новой версии перед включением.",
      "title": "Описание функции",
      "whatHappens": "Что произойдет после включения:"
    },
    "section": {
      "distribution": {
        "description": "Показывает информацию о версиях клиентов активных пользователей за последние 7 дней. GA версия рассчитывается независимо для каждого типа клиента.",
        "title": "Распределение версий клиентов"
      },
      "settings": {
        "description": "После включения система будет автоматически проверять версию клиента и блокировать запросы от пользователей со старыми версиями.",
        "title": "Настройки напоминания об обновлении"
      }
    },
    "table": {
      "currentGA": "Текущая GA версия:",
      "internalType": "Внутренний тип:",
      "lastActive": "Последняя активность",
      "latest": "Последняя",
      "needsUpgrade": "Требуется обновление",
      "noUsers": "Нет данных о пользователях",
      "status": "Статус",
      "unknown": "Неизвестно",
      "user": "Пользователь",
      "usersCount": "{count} пользователей",
      "version": "Текущая версия"
    },
    "title": "Напоминание об обновлении клиента",
    "toggle": {
      "description": "При включении система автоматически проверяет версию и блокирует старые версии.",
      "disableSuccess": "Проверка версии клиента отключена",
      "enable": "Включить проверку версии клиента",
      "enableSuccess": "Проверка версии клиента включена",
      "toggleFailed": "Ошибка переключения"
    }
  },
  "common": {
    "cancel": "Отменить",
    "completed": "Завершено",
    "confirm": "Подтвердить",
    "copied": "Ключ скопирован в буфер обмена",
    "copy": "Копировать",
    "copyFailed": "Ошибка копирования",
    "create": "Создать",
    "creating": "Создание...",
    "delete": "Удалить",
    "disabled": "Отключено",
    "edit": "Редактировать",
    "empty": "Результаты не найдены",
    "enabled": "Включено",
    "error": "Неизвестная ошибка",
    "failed": "Ошибка",
    "loading": "Загрузка...",
    "none": "Нет (нет пользователей с этой версией)",
    "refresh": "Обновить",
    "reset": "Сброс",
    "save": "Сохранить",
    "saving": "Сохранение...",
    "submit": "Отправить",
    "success": "Успех",
    "test": "Тестировать",
    "testing": "Тестирование...",
    "unlimited": "Без ограничений",
    "unlimited_desc": "Без ограничений",
    "update": "Обновить",
    "updating": "Обновление..."
  },
  "config": {
    "autoCleanup": "Автоматическая очистка логов",
    "autoCleanupDesc": "Автоматически очищать исторические логи по расписанию для освобождения места в БД.",
    "description": "Управление основными параметрами системы, влияющими на отображение и поведение статистики.",
    "form": {
      "allowGlobalView": "Разрешить просмотр глобального использования",
      "allowGlobalViewDesc": "При отключении обычные пользователи могут видеть только статистику использования своих ключей на панели.",
      "cleanupSchedule": "График очистки",
      "cleanupScheduleDesc": "Выбрать расписание автоматической очистки",
      "configUpdated": "Параметры системы обновлены. Страница обновится для применения изменений валюты.",
      "currencyDisplay": "Валюта",
      "currencyDisplayPlaceholder": "Выберите валюту",
      "currencyDisplayDesc": "После изменения все страницы и API будут использовать соответствующий символ валюты (только символ, без конвертации).",
      "keepDays": "Хранить дней",
      "keepDaysDesc": "Очищать логи старше указанного количества дней",
      "saveFailed": "Ошибка сохранения",
      "saveSuccess": "Сохранено успешно",
      "saveError": "Ошибка сохранения",
      "saveSettings": "Сохранить настройки",
      "siteTitle": "Название сайта",
      "siteTitlePlaceholder": "например: Claude Code Hub",
      "siteTitleRequired": "Название сайта не может быть пустым",
      "siteTitleDesc": "Используется для установки заголовка вкладки браузера и имени системы по умолчанию.",
      "enableAutoCleanup": "Включить автоочистку",
      "enableAutoCleanupDesc": "Автоматически очищать исторические логи по расписанию",
      "cleanupRetentionDays": "Хранить дней",
      "cleanupRetentionDaysRequired": "Хранить дней *",
      "cleanupRetentionDaysPlaceholder": "30",
      "cleanupRetentionDaysDesc": "Логи старше этого количества дней будут автоматически очищены (диапазон: 1-365 дней)",
      "cleanupScheduleLabel": "Время выполнения (Cron)",
      "cleanupScheduleRequired": "Время выполнения (Cron) *",
      "cleanupSchedulePlaceholder": "0 2 * * *",
      "cleanupScheduleCronDesc": "Cron-выражение, по умолчанию: 0 2 * * * (2 часа ночи ежедневно)",
      "cleanupScheduleCronExample": "Пример: 0 3 * * 0 (3 часа ночи каждое воскресенье)",
      "cleanupBatchSize": "Размер пакета",
      "cleanupBatchSizeRequired": "Размер пакета *",
      "cleanupBatchSizePlaceholder": "10000",
      "cleanupBatchSizeDesc": "Количество записей для удаления за раз (диапазон: 1000-100000, рекомендуется 10000)",
      "saveConfig": "Сохранить конфигурацию",
      "autoCleanupSaved": "Конфигурация автоочистки сохранена",
      "currencies": {
        "USD": "$ Доллар США (USD)",
        "CNY": "¥ Китайский юань (CNY)",
        "EUR": "€ Евро (EUR)",
        "JPY": "¥ Японская иена (JPY)",
        "GBP": "£ Фунт стерлингов (GBP)",
        "HKD": "HK$ Гонконгский доллар (HKD)",
        "TWD": "NT$ Новый тайваньский доллар (TWD)",
        "KRW": "₩ Южнокорейская вона (KRW)",
        "SGD": "S$ Сингапурский доллар (SGD)"
      }
    },
    "siteSettings": "Параметры сайта",
    "siteSettingsDesc": "Настройка названия сайта, валюты и политики отображения статистики.",
    "title": "Конфигурация"
  },
  "data": {
    "cleanup": {
      "descriptionWarning": "Очистка исторических данных логов для освобождения дискового пространства базы данных. Примечание: Статистические данные будут сохранены, но детали логов будут удалены навсегда.",
      "rangeLabel": "Диапазон очистки",
      "range": {
        "7days": "Логи старше 1 недели (7 дней)",
        "30days": "Логи старше 1 месяца (30 дней)",
        "90days": "Логи старше 3 месяцев (90 дней)",
        "180days": "Логи старше 6 месяцев (180 дней)"
      },
      "rangeDescription": {
        "7days": "1 неделю назад",
        "30days": "1 месяц назад",
        "90days": "3 месяца назад",
        "180days": "6 месяцев назад",
        "default": "{days} дней назад"
      },
      "willClean": "Будут очищены все записи логов с {range}",
      "button": "Очистить логи",
      "confirmTitle": "Подтверждение очистки логов",
      "confirmWarning": "Эта операция навсегда удалит все записи логов с {range} и не может быть отменена.",
      "previewLoading": "Подсчет...",
      "previewCount": "Будет удалено {count} записей логов",
      "previewError": "Не удается получить предварительный просмотр",
      "statisticsRetained": "✓ Статистические данные будут сохранены (для анализа трендов)",
      "logsDeleted": "✗ Детали логов будут удалены (содержимое запроса/ответа, информация об ошибках и т.д.)",
      "backupRecommendation": "Рекомендация: Экспортируйте резервную копию базы данных перед очисткой на случай, если потребуется восстановление.",
      "cancel": "Отмена",
      "confirm": "Подтвердить очистку",
      "cleaning": "Очистка...",
      "successMessage": "Успешно очищено {count} записей логов ({batches} пакетов, заняло {duration}с)",
      "failed": "Очистка не удалась",
      "error": "Не удалось очистить логи"
    },
    "description": "Управление резервной копией и восстановлением БД с полным импортом/экспортом и очисткой логов.",
    "export": {
      "descriptionFull": "Экспорт полного файла резервной копии базы данных (формат .dump) для миграции или восстановления данных. Резервная копия использует формат PostgreSQL custom format, автоматически сжимается и совместима с разными версиями базы данных.",
      "button": "Экспортировать базу данных",
      "exporting": "Экспорт...",
      "successMessage": "База данных успешно экспортирована!",
      "failed": "Экспорт не удался",
      "error": "Не удалось экспортировать базу данных"
    },
    "guide": {
      "backup": "Рекомендация безопасности: перед импортом сначала экспортируйте текущую БД как резервную копию.",
      "cleanup": "Очистка логов: физически удаляет исторические логи (необратимо). Таблица статистики будет сохранена. Рекомендуется сначала экспортировать резервную копию.",
      "docker": "Требования окружения: требует развертывания Docker Compose. Локальная разработка может не поддерживаться.",
      "format": "Формат резервной копии: использует PostgreSQL custom format (.dump), автоматически сжимается и совместим с разными версиями БД.",
      "merge": "Режим объединения: сохраняет существующие данные и пытается вставить из резервной копии. Конфликты первичного ключа могут привести к ошибкам.",
      "overwrite": "Режим перезаписи: удаляет все существующие данные перед импортом. Лучше всего для полного восстановления.",
      "title": "Инструкции и меры предосторожности"
    },
    "import": {
      "descriptionFull": "Восстановление базы данных из файла резервной копии. Поддерживает файлы резервных копий в формате PostgreSQL custom format (.dump).",
      "selectFileLabel": "Выбрать файл резервной копии",
      "fileSelected": "Выбрано: {name} ({size} МБ)",
      "fileError": "Пожалуйста, выберите файл резервной копии в формате .dump",
      "noFileSelected": "Сначала выберите файл резервной копии",
      "cleanFirstLabel": "Очистить существующие данные (режим перезаписи)",
      "cleanFirstDescription": "Удалить все существующие данные перед импортом, чтобы база данных точно соответствовала резервной копии. Если не отмечено, будет предпринята попытка объединения данных, но это может не удаться из-за конфликтов первичных ключей.",
      "button": "Импортировать базу данных",
      "importing": "Импорт...",
      "progressTitle": "Прогресс импорта",
      "confirmTitle": "Подтверждение импорта базы данных",
      "confirmOverwrite": "Вы выбрали 'Режим перезаписи', который удалит все существующие данные перед импортом резервной копии.",
      "confirmMerge": "Вы выбрали 'Режим объединения', который попытается импортировать резервную копию, сохраняя существующие данные.",
      "warningOverwrite": "⚠️ Предупреждение: Это действие необратимо, все текущие данные будут навсегда удалены!",
      "warningMerge": "⚠️ Примечание: Импорт может не удаться при наличии конфликтов первичных ключей.",
      "backupFile": "Файл резервной копии:",
      "backupRecommendation": "Рекомендуется экспортировать текущую базу данных в качестве резервной копии перед продолжением.",
      "cancel": "Отмена",
      "confirm": "Подтвердить импорт",
      "successMessage": "Импорт данных завершен!",
      "failedMessage": "Импорт данных не удался, проверьте подробные логи",
      "error": "Не удалось импортировать базу данных",
      "streamError": "Не удается прочитать поток ответа",
      "errorUnknown": "Неизвестная ошибка"
    },
    "status": {
      "loading": "Загрузка...",
      "error": "Не удалось получить статус базы данных",
      "retry": "Повторить",
      "connected": "База данных подключена",
      "unavailable": "База данных недоступна",
      "tables": "{count} таблиц"
    },
    "title": "Управление данными",
    "section": {
      "status": {
        "title": "Статус базы данных",
        "description": "Просмотр текущего статуса подключения к базе данных и основной информации."
      },
      "cleanup": {
        "title": "Очистка логов",
        "description": "Очистка исторических данных логов для освобождения дискового пространства базы данных. Примечание: Статистические данные будут сохранены, но детали логов будут удалены навсегда."
      },
      "export": {
        "title": "Экспорт данных",
        "description": "Экспорт полного файла резервной копии базы данных (формат .dump) для миграции или восстановления данных."
      },
      "import": {
        "title": "Импорт данных",
        "description": "Восстановление базы данных из файла резервной копии. Поддерживает файлы резервных копий в формате PostgreSQL custom format (.dump)."
      }
    }
  },
  "errors": {
    "addFailed": "Ошибка добавления поставщика",
    "addSuccess": "Добавлено успешно",
    "deleteFailed": "Ошибка удаления поставщика",
    "deleteSuccess": "Удалено успешно",
    "editFailed": "Ошибка обновления поставщика",
    "editSuccess": "Обновлено успешно",
    "loadFailed": "Ошибка загрузки параметров уведомлений",
    "saveFailed": "Ошибка сохранения",
    "saveFailed_error": "Ошибка сохранения параметров",
    "saveSuccess": "Сохранено успешно",
    "syncFailed": "Ошибка синхронизации",
    "syncSuccess": "Синхронизация успешна",
    "testFailed": "Ошибка тестирования",
    "testFailedRetry": "Ошибка тестирования. Пожалуйста, повторите.",
    "unknownError": "Ошибка при выполнении операции"
  },
  "logs": {
    "description": "Динамическая регулировка уровня логирования для контроля подробности.",
    "subtitle": "Контроль уровня логирования",
    "subtitleDesc": "Изменения вступают в силу немедленно без перезагрузки. Полезно для отладки в производстве.",
    "section": {
      "title": "Контроль уровня логирования",
      "description": "Изменения вступают в силу немедленно без перезапуска сервиса."
    },
    "levels": {
      "fatal": {
        "label": "Fatal",
        "description": "Только критические ошибки"
      },
      "error": {
        "label": "Error",
        "description": "Сообщения об ошибках"
      },
      "warn": {
        "label": "Warn",
        "description": "Предупреждения + Ошибки"
      },
      "info": {
        "label": "Info",
        "description": "Ключевые бизнес-события + Предупреждения + Ошибки (Рекомендуется для продакшена)"
      },
      "debug": {
        "label": "Debug",
        "description": "Отладочная информация + Все уровни (Рекомендуется для разработки)"
      },
      "trace": {
        "label": "Trace",
        "description": "Очень подробная трассировка + Все уровни"
      }
    },
    "form": {
      "currentLevel": "Текущий уровень логирования",
      "selectLevel": "Выбрать уровень логирования",
      "save": "Сохранить параметры",
      "saving": "Сохранение...",
      "success": "Уровень логирования установлен: {level}",
      "failed": "Ошибка установки",
      "failedError": "Ошибка установки уровня логирования",
      "fetchFailed": "Ошибка получения уровня логирования",
      "effectiveImmediately": "Изменения уровня логирования вступают в силу немедленно без перезапуска сервиса.",
      "levelGuideTitle": "Руководство по уровням логирования",
      "levelGuideFatal": "Fatal/Error: Показывать только ошибки, минимальное логирование, подходит для высоконагруженного продакшена",
      "levelGuideWarn": "Warn: Включает предупреждения (ограничение скорости, открытие автомата защиты и т.д.) + Ошибки",
      "levelGuideInfo": "Info (Рекомендуется для продакшена): Показывает ключевые бизнес-события (выбор поставщика, повторное использование сессии, синхронизация цен) + Предупреждения + Ошибки",
      "levelGuideDebug": "Debug (Рекомендуется для разработки): Включает подробную отладочную информацию, подходит для устранения проблем",
      "levelGuideTrace": "Trace: Очень подробная трассировочная информация, включает все детали",
      "changeNotice": "Текущий уровень {current}, после сохранения переключится на {selected}"
    },
    "title": "Управление логами"
  },
  "nav": {
    "apiDocs": "API документация",
    "clientVersions": "Напоминание об обновлении",
    "config": "Конфигурация",
    "data": "Управление данными",
    "logs": "Логи",
    "notifications": "Уведомления",
    "prices": "Прайс-лист",
    "providers": "Поставщики",
    "sensitiveWords": "Чувствительные слова"
  },
  "notifications": {
    "circuitBreaker": {
      "description": "Немедленно отправить оповещение когда поставщик полностью замкнут",
      "enable": "Включить оповещение автоматического выключателя",
      "test": "Проверить соединение",
      "title": "Оповещение автоматического выключателя",
      "webhook": "URL Webhook",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=..."
    },
    "costAlert": {
      "description": "Отправить оповещение когда расходы превышают порог квоты",
      "enable": "Включить оповещение о стоимости",
      "interval": "Интервал проверки (минуты)",
      "test": "Проверить соединение",
      "threshold": "Порог оповещения",
      "thresholdHelp": "Оповестить когда расходы достигают {percent}% квоты",
      "thresholdLabel": "Порог оповещения: {percent}%",
      "title": "Оповещение о стоимости",
      "webhook": "URL Webhook",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=..."
    },
    "dailyLeaderboard": {
      "description": "Отправлять ежедневно рейтинг Top N пользователей по расходам",
      "enable": "Включить ежедневный рейтинг",
      "test": "Проверить соединение",
      "time": "Время отправки",
      "timeError": "Ошибка формата времени, должно быть HH:mm",
      "timePlaceholder": "09:00",
      "title": "Ежедневный рейтинг расходов",
      "topN": "Показать Top N",
      "webhook": "URL Webhook",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=..."
    },
    "description": "Настройка отправки уведомлений через робота WeChat Work",
    "form": {
      "loadError": "Ошибка загрузки параметров уведомлений",
      "loading": "Загрузка...",
      "save": "Сохранить параметры",
      "saveError": "Ошибка сохранения параметров",
      "saveFailed": "Ошибка сохранения",
      "saving": "Сохранение...",
      "success": "Параметры уведомлений сохранены и перепланы переданы",
      "testError": "Ошибка проверки соединения",
      "testFailed": "Ошибка тестирования",
      "testFailedRetry": "Ошибка тестирования. Пожалуйста, повторите.",
      "testNoResult": "Тестирование успешно но результат не возвращен",
      "testSuccess": "Тестовое сообщение отправлено. Проверьте WeChat Work.",
      "webhookRequired": "Пожалуйста, сначала заполните URL Webhook"
    },
    "global": {
      "description": "Включить или отключить все функции отправки уведомлений",
      "enable": "Включить отправку уведомлений",
      "title": "Главный переключатель уведомлений"
    },
    "title": "Отправка уведомлений"
  },
  "prices": {
    "description": "Управление конфигурацией платформы и ценами моделей",
    "dialog": {
      "description": "Загрузить JSON файл для обновления прайс-листа",
      "fileSizeLimit": "Размер файла не может превышать 10MB",
      "fileSizeLimitSmall": "Размер файла не превышает 10MB",
      "getError": "Ошибка получения ключа",
      "readError": "Ошибка получения ключа",
      "selectFile": "Нажмите для выбора JSON или перетащите сюда",
      "title": "Обновить прайс-лист",
      "upload": "Загрузить",
      "uploading": "Загрузка..."
    },
    "noData": "Система имеет встроенный прайс-лист. Используйте кнопки выше для синхронизации.",
    "noModels": "Цены моделей не найдены",
    "search": "Поиск по названию модели...",
    "subtitle": "Цены моделей",
    "subtitleDesc": "Управление ценами AI моделей",
    "sync": "Синхронизировать цены LiteLLM",
    "syncFailed": "Ошибка синхронизации",
    "syncFailedError": "Ошибка синхронизации:",
    "syncNoResult": "Прайс-лист обновлен но результат не возвращен",
    "syncSuccess": "Прайс-лист обновлен успешно",
    "syncing": "Синхронизация...",
    "table": {
      "cachePrice": "Цена кэша",
      "inputPrice": "Цена ввода ($/M)",
      "model": "Модель",
      "outputPrice": "Цена вывода ($/M)",
      "updatedAt": "Обновлено"
    },
    "title": "Прайс-лист",
    "upload": "Обновить прайс-лист моделей",
    "uploadFailed": "Ошибка получения данных о ценах:",
    "uploadSuccess": "Прайс-лист обновлен успешно"
  },
  "providers": {
    "add": "Добавить поставщика",
    "addFailed": "Ошибка добавления поставщика",
    "addProvider": "Добавить провайдера",
    "addSuccess": "Поставщик добавлен успешно",
    "circuitBroken": "Цепь разомкнута",
    "clone": "Дублировать поставщика",
    "cloneFailed": "Ошибка копирования",
    "confirmDelete": "Вы уверены, что хотите удалить этого поставщика?",
    "confirmDeleteDesc": "Вы уверены, что хотите удалить провайдера \"{name}\"? Это действие не может быть отменено.",
    "confirmDeleteProvider": "Подтвердить удаление провайдера?",
    "confirmDeleteProviderDesc": "Вы уверены, что хотите удалить провайдера \"{name}\"? Это действие не может быть восстановлено.",
    "createProvider": "Добавить провайдера",
    "delete": "Удалить поставщика",
    "deleteFailed": "Ошибка удаления поставщика",
    "deleteSuccess": "Успешно удалено",
    "description": "Настройка поставщиков API и контроль статуса доступности.",
    "disabledStatus": "Отключено",
    "displayCount": "Показано {filtered} / {total} провайдеров",
    "edit": "Редактировать поставщика",
    "editFailed": "Ошибка обновления поставщика",
    "editProvider": "Редактировать провайдера",
    "enabledStatus": "Включено",
    "form": {
      "addRedirect": "Добавить переправку",
      "allowAllModels": "✓ Разрешить все модели (рекомендуется)",
      "apiAddress": "Адрес API",
      "apiAddressPlaceholder": "Например: https://open.bigmodel.cn/api/anthropic",
      "apiAddressRequired": "Адрес API *",
      "apiKey": "API ключ",
      "apiKeyCurrent": "Текущий ключ:",
      "apiKeyLeaveEmpty": "（оставьте пустым, чтобы не изменять）",
      "apiKeyLeaveEmptyDesc": "Оставьте пустым, чтобы не изменять ключ",
      "apiKeyOptional": "Оставьте пустым, чтобы оставить текущий ключ",
      "apiKeyPlaceholder": "Введите API ключ",
      "apiKeyRequired": "API ключ *",
      "baseUrl": "Базовый URL",
      "baseUrlPlaceholder": "например: https://open.bigmodel.cn/api/anthropic",
      "baseUrlRequired": "Пожалуйста, сначала заполните URL поставщика",
      "circuitBreakerConfig": "Конфигурация автоматического выключателя",
      "circuitBreakerConfigSummary": "{failureThreshold} сбоев / {openDuration} мин. размыкания / {successThreshold} успехов для восстановления",
      "circuitBreakerDesc": "Автоматическое размыкание при последовательных сбоях провайдера для предотвращения влияния на общее качество сервиса",
      "clearSearch": "Очистить поиск",
      "codexInstructions": "Политика инструкций Codex",
      "codexInstructionsAuto": "Автоматически (рекомендуется)",
      "codexInstructionsDesc": "(определяет политику планирования)",
      "codexInstructionsForce": "Принудительно официальные",
      "codexInstructionsKeep": "Сохранить оригинал",
      "codexStrategyAutoDesc": "Передавать instructions клиента, автоматически повторять с официальным prompt при ошибке 400",
      "codexStrategyAutoLabel": "Автоматически (рекомендуется)",
      "codexStrategyConfig": "Стратегия Codex Instructions",
      "codexStrategyConfigAuto": "Автоматически (рекомендуется)",
      "codexStrategyConfigForce": "Принудительно официальные",
      "codexStrategyConfigKeep": "Передавать как есть",
      "codexStrategyDesc": "Управляет обработкой поля instructions в запросах Codex, влияет на совместимость с вышестоящими узлами",
      "codexStrategyForceDesc": "Всегда использовать официальные Codex CLI instructions (около 4000+ символов)",
      "codexStrategyForceLabel": "Принудительно официальные",
      "codexStrategyHint": "Подсказка: некоторые строгие узлы Codex (например, 88code, foxcode) требуют официальные instructions, выберите стратегию \"Автоматически\" или \"Принудительно официальные\"",
      "codexStrategyKeepDesc": "Всегда передавать instructions клиента без автоматического повтора (подходит для гибких узлов)",
      "codexStrategyKeepLabel": "Передавать как есть",
      "codexStrategySelect": "Выбор стратегии",
      "collapseAll": "Свернуть все расширенные настройки",
      "confirmAdd": "Подтвердить добавление",
      "confirmAddPending": "Добавление...",
      "confirmUpdate": "Подтвердить обновление",
      "confirmUpdatePending": "Обновление...",
      "costMultiplier": "Множитель стоимости",
      "costMultiplierDesc": "например: A (стоимость 1.0x), C (стоимость 0.8x)",
      "costMultiplierLabel": "Коэффициент стоимости",
      "costMultiplierPlaceholder": "1.0",
      "deleteButton": "Удалить",
      "enabled": "Включено",
      "expandAll": "Развернуть все расширенные настройки",
      "failureThreshold": "Порог сбоев (раз)",
      "failureThresholdDesc": "Сколько последовательных сбоев до размыкания",
      "failureThresholdPlaceholder": "5",
      "filterAllProviders": "Все поставщики",
      "filterByType": "Фильтр по типу",
      "filterProvider": "Фильтр типа поставщика",
      "group": "Группа",
      "groupPlaceholder": "например: premium, economy",
      "joinClaudePool": "Присоединиться к пулу планирования Claude",
      "joinClaudePoolDesc": "При включении этот поставщик будет участвовать в балансировке нагрузки вместе с поставщиками типа Claude",
      "joinClaudePoolHelp": "Доступно только при наличии перенаправлений на модели claude-* в конфигурации. При включении этот поставщик также будет участвовать в выборе при запросах моделей claude-*.",
      "leaveEmpty": "Оставьте пустым для неограниченного доступа",
      "limit0Means": "0 означает без ограничений",
      "limit5hLabel": "Лимит расходов за 5 часов (USD)",
      "limitAmount5h": "Лимит расходов за 5 часов (USD)",
      "limitAmount5hDesc": "например: Поставщик B имеет лимит $10, уже потрачено $9.8",
      "limitAmountMonthly": "Месячный лимит расходов (USD)",
      "limitAmountWeekly": "Недельный лимит расходов (USD)",
      "limitConcurrent": "Лимит параллельных сеансов",
      "limitConcurrentDesc": "например: Поставщик C имеет лимит 2, в данный момент 2 активных сеанса",
      "limitConcurrentLabel": "Лимит одновременных сеансов",
      "limitMonthlyLabel": "Месячный лимит расходов (USD)",
      "limitPlaceholder0": "0 означает без ограничений",
      "limitPlaceholderUnlimited": "Оставьте пустым для неограниченного доступа",
      "limitWeeklyLabel": "Недельный лимит расходов (USD)",
      "modelRedirects": "Перенаправление моделей",
      "modelRedirectsAddNew": "Добавить новое правило",
      "modelRedirectsCurrentRules": "Текущие правила ({count})",
      "modelRedirectsDesc": "Переправить запросы Claude к другим поддерживаемым моделям",
      "modelRedirectsEmpty": "Нет правил перенаправления. После добавления правил система автоматически перезапишет имена моделей в запросах.",
      "modelRedirectsExists": "Правило перенаправления для модели \"{model}\" уже существует",
      "modelRedirectsLabel": "Конфигурация перенаправления моделей",
      "modelRedirectsOptional": "(необязательно)",
      "modelRedirectsSourceModel": "Модель запроса пользователя",
      "modelRedirectsSourcePlaceholder": "например: claude-sonnet-4-5-20250929",
      "modelRedirectsSourceRequired": "Имя исходной модели не может быть пустым",
      "modelRedirectsTargetModel": "Фактически перенаправляемая модель",
      "modelRedirectsTargetPlaceholder": "например: glm-4.6",
      "modelRedirectsTargetRequired": "Имя целевой модели не может быть пустым",
      "modelWhitelist": "Белый список моделей",
      "modelWhitelistAllowAll": "Разрешить все модели {type}",
      "modelWhitelistAllowAllClause": "Разрешить все модели Claude",
      "modelWhitelistAllowAllOpenAI": "Разрешить все модели OpenAI",
      "modelWhitelistClear": "Очистить",
      "modelWhitelistDesc": "Ограничить модели, которые может обрабатывать этот поставщик. По умолчанию поставщик может обрабатывать все модели этого типа.",
      "modelWhitelistLabel": "Разрешенные модели",
      "modelWhitelistLoading": "Загрузка...",
      "modelWhitelistManualAdd": "Добавить модель вручную",
      "modelWhitelistManualDesc": "Поддерживает добавление любого имени модели (не ограничено прайс-листом)",
      "modelWhitelistManualPlaceholder": "Введите имя модели (например, gpt-5-turbo)",
      "modelWhitelistNotFound": "Модели не найдены",
      "modelWhitelistSearchPlaceholder": "Поиск по имени модели...",
      "modelWhitelistSelectAll": "Выбрать все ({count})",
      "modelWhitelistSelected": "Выбрано {count} моделей",
      "modelWhitelistSelectedOnly": "Разрешены только выбранные {count} моделей. Запросы других моделей не будут направлены к этому поставщику.",
      "name": "Имя",
      "namePlaceholder": "Введите имя поставщика",
      "openDuration": "Длительность размыкания (минуты)",
      "openDurationDesc": "Время автоматического перехода в полуоткрытое состояние после размыкания",
      "openDurationPlaceholder": "30",
      "priority": "Приоритет",
      "priorityDesc": "В пределах одного приоритета сортировка по множителю стоимости от низкого к высокому",
      "priorityLabel": "Приоритет",
      "priorityPlaceholder": "0",
      "providerGroupDesc": "Метка группы поставщика. Пользователь может использовать этого поставщика только если его providerGroup совпадает с этим значением. Пример: установка \"premium\" означает использование только пользователями с providerGroup=\"premium\"",
      "providerGroupLabel": "Группа поставщика",
      "providerGroupPlaceholder": "например: premium, economy",
      "providerName": "Имя поставщика",
      "providerNamePlaceholder": "например: Zhipu",
      "providerNameRequired": "Имя поставщика *",
      "providerType": "Тип поставщика",
      "providerTypeDesc": "Выберите тип формата API поставщика.",
      "providerTypeDisabledNote": "Примечание: функции типов Gemini CLI и OpenAI Compatible находятся в разработке и временно недоступны",
      "proxy": "Прокси",
      "proxyAddressFormats": "Поддерживаемые форматы:",
      "proxyAddressLabel": "Адрес прокси",
      "proxyAddressOptional": "(необязательно)",
      "proxyAddressPlaceholder": "например: http://proxy.example.com:8080 или socks5://127.0.0.1:1080",
      "proxyConfig": "Конфигурация прокси",
      "proxyConfigDesc": "Настройка прокси-сервера для улучшения подключения к поставщику (поддерживает HTTP, HTTPS, SOCKS4, SOCKS5)",
      "proxyConfigNone": "Не настроен",
      "proxyConfigSummary": "Прокси настроен",
      "proxyConfigSummaryFallback": " (откат включен)",
      "proxyConfigured": "Прокси настроен",
      "proxyFallback": "Откат при ошибке прокси",
      "proxyFallbackDesc": "Перейти на прямое соединение при ошибке прокси",
      "proxyFallbackLabel": "代理失败时降级到直连",
      "proxyNotConfigured": "Не настроен",
      "proxyTestButton": "测试连接",
      "proxyTestDesc": "测试通过配置的代理访问供应商 URL（使用 HEAD 请求，不消耗额度）",
      "proxyTestFailed": "连接失败",
      "proxyTestFillUrl": "请先填写供应商 URL",
      "proxyTestLabel": "连接测试",
      "proxyTestNetworkError": "网络错误: {error}",
      "proxyTestProxyError": "代理错误: {error}",
      "proxyTestResponseTime": "响应时间: {time}",
      "proxyTestResultConnectionMethod": "连接方式: {via}",
      "proxyTestResultConnectionMethodDirect": "直连",
      "proxyTestResultConnectionMethodProxy": "代理",
      "proxyTestResultErrorType": "错误类型: {type}",
      "proxyTestResultFailed": "连接失败",
      "proxyTestResultMessage": "{message}",
      "proxyTestResultResponseTime": "响应时间: {time}ms",
      "proxyTestResultStatusCode": "状态码: {code}",
      "proxyTestResultSuccess": "连接成功 {via}",
      "proxyTestStatusCode": "| 状态码: {code}",
      "proxyTestSuccess": "连接成功",
      "proxyTestTesting": "测试中...",
      "proxyTestTimeout": "连接超时（5秒）。请检查：\n1. 代理服务器是否可访问\n2. 代理地址和端口是否正确\n3. 代理认证信息是否正确",
      "proxyTestViaDirect": "（直连）",
      "proxyTestViaProxy": "（通过代理）",
      "proxyUrl": "Адрес прокси",
      "proxyUrlPlaceholder": "например: http://proxy.example.com:8080 или socks5://127.0.0.1:1080",
      "rateLimitConfig": "限流配置",
      "rateLimitConfigNone": "无限制",
      "rateLimitConfigSummary": "5h: ${fiveHour}, 周: ${weekly}, 月: ${monthly}, 并发: {concurrent}",
      "remark": "Примечание",
      "remarkPlaceholder": "Необязательно: добавить примечание...",
      "removeRedirect": "Удалить переправку",
      "routingConfig": "路由配置",
      "routingConfigNone": "未配置",
      "routingConfigSummary": "{models} 个模型白名单, {redirects} 个重定向",
      "scheduleParams": "调度参数",
      "searchClear": "清除搜索",
      "searchPlaceholder": "Поиск по имени, URL, примечанию...",
      "selectProviderType": "Выбрать тип поставщика",
      "sort": "Сортировать поставщиков",
      "sortByCost": "По стоимости",
      "sortByCreated": "По дате создания (новое-старое)",
      "sortByName": "По имени (A-Z)",
      "sortByPriority": "По приоритету (высокое-низкое)",
      "sortByWeight": "По весу (высокое-низкое)",
      "sourceModel": "Исходная модель",
      "sourceModelPlaceholder": "например: claude-sonnet-4-5-20250929",
      "sourceModelRequired": "Имя исходной модели не может быть пустым",
      "successThreshold": "恢复阈值（次）",
      "successThresholdDesc": "半开状态下成功多少次后完全恢复",
      "successThresholdPlaceholder": "2",
      "targetModel": "Целевая модель",
      "targetModelPlaceholder": "например: glm-4.6",
      "targetModelRequired": "Имя целевой модели не может быть пустым",
      "testProxy": "Проверить соединение",
      "testProxyFailed": "Ошибка тестирования прокси",
      "testProxyFailedError": "Ошибка проверки соединения:",
      "testProxySuccess": "Соединение прокси успешно",
      "validUrlRequired": "请输入有效的 API 地址",
      "websiteUrl": "供应商官网地址",
      "websiteUrlDesc": "供应商官网地址，用于快速跳转管理",
      "websiteUrlInvalid": "请输入有效的供应商官网地址",
      "websiteUrlPlaceholder": "https://example.com",
      "weight": "Вес",
      "weightDesc": "Взвешенная случайная вероятность. В пределах одного приоритета большее число означает выше вероятность выбора.",
      "weightLabel": "权重",
      "weightPlaceholder": "1"
    },
    "guide": {
      "after": "过滤后：",
      "before": "过滤前：",
      "bestPracticesConcurrent": "• 并发控制：根据供应商 API 限制设置 Session 并发数",
      "bestPracticesCost": "• 成本倍率：官方倍率为 1.0，自建服务可设置为 0.8-1.2",
      "bestPracticesLimit": "• 限额设置：根据预算设置 5 小时、7 天、30 天限额",
      "bestPracticesPriority": "• 优先级设置：核心供应商设为 0，备用供应商设为 1-3",
      "bestPracticesTitle": "最佳实践建议",
      "bestPracticesWeight": "• 权重配置：根据供应商容量设置权重（容量大 = 权重高）",
      "circuitBreaker": "Проверка автоматического выключателя",
      "circuitBreakerOpen": "A отфильтрован, осталось: B, C, D",
      "circuitBreakerRecovery": "A автоматически восстанавливается в полуоткрытое после 60 секунд",
      "circuitBreakerRecovery5h": "Автоматическое восстановление после 5-часового скользящего окна",
      "costOptimize": "2️⃣ 成本优化：同优先级内，成本倍率低的供应商有更高概率",
      "costSort": "Откат по стоимости",
      "costSortExample": "Все поставщики: A (default), B (premium), C (premium), D (economy)",
      "costSortProb": "Более дешевый C имеет более высокую вероятность выбора",
      "costSortResult": "После сортировки: C (0.8x), A (1.0x)",
      "decision": "决策：",
      "group": "Фильтрация групп пользователей",
      "groupDesc": "Если пользователь указал группу поставщиков, система приоритизирует выбор из этой группы",
      "groupDowngrade": "Записать предупреждение и выбрать из глобального пула",
      "groupExample": "Пользователь настроил providerGroup = 'premium'",
      "groupFallback": "Если в группе нет доступных поставщиков, откат на всех поставщиков",
      "groupFiltered": "Выбрать только из A и C, B и D отфильтрованы",
      "groupUnavailable": "Все поставщики в группе 'vip' отключены или превышены",
      "health": "Фильтрация здоровья (автоматический выключатель + ограничение)",
      "healthCheck": "Проверить, включен ли B и работоспособен",
      "healthCheckAmountLimit": "Проверить превышение лимитов (5ч, 7д, 30д)",
      "healthCheckAmountLimitExample": "Лимит поставщика B $10 (5ч), потрачено $9.8",
      "healthCheckCircuit": "Поставщик A потерпел неудачу 5 раз, статус: открыт",
      "healthCheckConcurrent": "Проверить количество активных сеансов на лимит",
      "healthCheckConcurrentExample": "Лимит поставщика C 2, активных 2 сеанса",
      "healthFilter": "3️⃣ 健康过滤：自动跳过熔断或超限的供应商",
      "healthFiltered": "B отфильтрован (близко к лимиту), осталось: C, D",
      "healthFiltered2": "C отфильтрован (полный), осталось: D",
      "history": "Проверить историю запросов",
      "historyDesc": "Запрос поставщиков, используемых этим ключом за последние 10 секунд",
      "priority": "Приоритизация по уровням",
      "priorityExample": "4 включенных поставщика с разными приоритетами",
      "priorityFirst": "1️⃣ 优先级优先：只从最高优先级（数值最小）的供应商中选择",
      "priorityResult": "Отфильтровано к приоритету (0): A, C",
      "priorityStep": "Система сначала фильтрует по приоритету, выбирая только из поставщиков с наивысшим приоритетом",
      "randomResult": "В конце выбран C",
      "randomSelect": "Взвешенный случайный",
      "reset": "Ручной сброс автоматического выключателя",
      "resetSuccess": "Автоматический выключатель сброшен",
      "scenario1Desc": "系统首先按优先级过滤，只从最高优先级的供应商中选择",
      "scenario1Step1": "初始状态",
      "scenario1Step1After": "筛选出最高优先级（0）的供应商：A, C",
      "scenario1Step1Before": "供应商 A (优先级 0), B (优先级 1), C (优先级 0), D (优先级 2)",
      "scenario1Step1Decision": "只从 A 和 C 中选择，B 和 D 被过滤",
      "scenario1Step1Desc": "有 4 个已启用的供应商，优先级各不相同",
      "scenario1Step2": "成本排序",
      "scenario1Step2After": "排序后：C (0.8x), A (1.0x)",
      "scenario1Step2Before": "A (成本 1.0x), C (成本 0.8x)",
      "scenario1Step2Decision": "成本更低的 C 有更高的被选中概率",
      "scenario1Step2Desc": "在同优先级内，按成本倍率从低到高排序",
      "scenario1Step3": "加权随机",
      "scenario1Step3After": "C 被选中概率 75%, A 被选中概率 25%",
      "scenario1Step3Before": "C (权重 3), A (权重 1)",
      "scenario1Step3Decision": "最终随机选择了 C",
      "scenario1Step3Desc": "使用权重进行随机选择，权重越高被选中概率越大",
      "scenario1Title": "优先级分层选择",
      "scenario2Desc": "如果用户指定了供应商组，系统会优先从该组中选择",
      "scenario2Step1": "检查用户分组",
      "scenario2Step1After": "过滤出 'premium' 组：B, C",
      "scenario2Step1Before": "所有供应商：A (default), B (premium), C (premium), D (economy)",
      "scenario2Step1Decision": "只从 B 和 C 中选择",
      "scenario2Step1Desc": "用户配置了 providerGroup = 'premium'",
      "scenario2Step2": "分组降级",
      "scenario2Step2After": "降级到所有启用的供应商：A, B, C, D",
      "scenario2Step2Before": "用户组 'vip' 内的供应商全部禁用或超限",
      "scenario2Step2Decision": "记录警告并从全局供应商池中选择",
      "scenario2Step2Desc": "如果用户组内没有可用供应商，降级到所有供应商",
      "scenario2Title": "用户分组过滤",
      "scenario3Desc": "系统自动过滤掉熔断或超限的供应商",
      "scenario3Step1": "熔断器检查",
      "scenario3Step1After": "A 被过滤，剩余：B, C, D",
      "scenario3Step1Before": "供应商 A 连续失败 5 次，熔断器状态：open",
      "scenario3Step1Decision": "A 在 60 秒后自动恢复到半开状态",
      "scenario3Step1Desc": "连续失败 5 次后熔断器打开，60 秒内不可用",
      "scenario3Step2": "金额限流",
      "scenario3Step2After": "B 被过滤（接近限额），剩余：C, D",
      "scenario3Step2Before": "供应商 B 的 5 小时限额 $10，已消耗 $9.8",
      "scenario3Step2Decision": "5 小时窗口滑动后自动恢复",
      "scenario3Step2Desc": "检查 5 小时、7 天、30 天的消费额度是否超限",
      "scenario3Step3": "并发 Session 限制",
      "scenario3Step3After": "C 被过滤（已满），剩余：D",
      "scenario3Step3Before": "供应商 C 并发限制 2，当前活跃 Session 数：2",
      "scenario3Step3Decision": "Session 过期（5 分钟）后自动释放",
      "scenario3Step3Desc": "检查当前活跃 Session 数是否超过配置的并发限制",
      "scenario3Title": "健康度过滤（熔断器 + 限流）",
      "scenario4Desc": "连续对话优先使用同一供应商，利用 Claude 的上下文缓存",
      "scenario4Step1": "检查历史请求",
      "scenario4Step1After": "检查 B 是否启用且健康",
      "scenario4Step1Before": "最近一次请求使用了供应商 B",
      "scenario4Step1Decision": "B 可用，直接复用，跳过随机选择",
      "scenario4Step1Desc": "查询该 API Key 最近 10 秒内使用的供应商",
      "scenario4Step2": "复用失效",
      "scenario4Step2After": "进入正常选择流程",
      "scenario4Step2Before": "上次使用的供应商 B 已被禁用或熔断",
      "scenario4Step2Decision": "从其他可用供应商中选择",
      "scenario4Step2Desc": "如果上次使用的供应商不可用，则重新选择",
      "scenario4Title": "会话复用机制",
      "scenariosTitle": "交互式场景演示",
      "session": "Механизм переиспользования сеансов",
      "sessionDesc": "Если последний использованный поставщик недоступен, переходим к переполнению",
      "sessionExample": "Последний запрос использовал поставщика B",
      "sessionExpired": "Сеанс автоматически освобождается после истечения (5 минут)",
      "sessionFallback": "Выбрать из других доступных поставщиков",
      "sessionLastUsed": "B доступен, переиспользуем, пропускаем случайный выбор",
      "sessionReuse": "4️⃣ 会话复用：连续对话复用同一供应商，节省上下文成本",
      "sessionUnavailable": "Последний использованный поставщик B отключен или замкнут",
      "step": "步骤",
      "title": "核心原则",
      "weight": "Взвешенный случайный выбор по весу",
      "weightCalc": "C имеет вероятность 75%, A имеет вероятность 25%",
      "weightExample": "C (вес 3), A (вес 1)"
    },
    "keyLoading": "加载中...",
    "noProviders": "暂无服务商配置",
    "noProvidersDesc": "添加你的第一个 API 服务商",
    "notFound": "Поставщики не найдены",
    "official": "官网",
    "resetCircuit": "熔断器已重置",
    "resetCircuitDesc": "供应商 \"{name}\" 的熔断状态已解除",
    "resetCircuitFailed": "重置熔断器失败",
    "scheduling": "Подробное объяснение политики планирования",
    "schedulingDesc": "Понимание того, как работает выбор поставщика: приоритизация, переиспользование сеансов, балансировка нагрузки и отказоустойчивость",
    "searchNoResults": "未找到匹配的供应商",
    "searchResults": "找到 {count} 个匹配的供应商",
    "section": {
      "description": "配置上游服务商的金额限流和并发限制，留空表示无限制。",
      "title": "服务商管理"
    },
    "subtitle": "Управление поставщиками",
    "subtitleDesc": "Настройка ограничений по расходам и параллельным сеансам. Оставьте пустым для неограниченного доступа.",
    "title": "Управление поставщиками",
    "todayUsage": "今日用量",
    "todayUsageCount": "{count} 次",
    "toggleFailed": "状态切换失败",
    "toggleSuccess": "供应商已{status}",
    "toggleSuccessDesc": "供应商 \"{name}\" 状态已更新",
    "updateFailed": "更新服务商失败",
    "viewKey": "查看完整 API Key",
    "viewKeyDesc": "请妥善保管，不要泄露给他人"
  },
  "sensitiveWords": {
    "add": "Добавить чувствительное слово",
    "addFailed": "Ошибка создания чувствительного слова",
    "addSuccess": "Чувствительное слово создано успешно",
    "cacheStats": "Статистика кэша: Содержит({containsCount}) Точное({exactCount}) Регулярное({regexCount})",
    "confirmDelete": "Вы уверены, что хотите удалить чувствительное слово \"{word}\"?",
    "delete": "Удалить чувствительное слово",
    "deleteFailed": "Ошибка удаления",
    "deleteSuccess": "Чувствительное слово удалено успешно",
    "description": "Настройка фильтрации чувствительных слов для блокирования чувствительного контента.",
    "dialog": {
      "addDescription": "Настройте правила фильтрации чувствительных слов. Совпадающие запросы не будут пересылаться.",
      "addTitle": "Добавить чувствительное слово",
      "creating": "Создание...",
      "descriptionLabel": "Описание",
      "descriptionPlaceholder": "Необязательно: Добавить описание...",
      "editDescription": "Изменить конфигурацию чувствительного слова. Изменения автоматически обновят кэш.",
      "editTitle": "Редактировать чувствительное слово",
      "matchTypeContains": "Частичное совпадение - Блокировать, если текст содержит это слово",
      "matchTypeExact": "Точное совпадение - Блокировать только при точном совпадении",
      "matchTypeLabel": "Тип совпадения *",
      "matchTypeRegex": "Регулярное выражение - Поддержка сложного сопоставления шаблонов",
      "saving": "Сохранение...",
      "wordLabel": "Чувствительное слово *",
      "wordPlaceholder": "Введите чувствительное слово...",
      "wordRequired": "Пожалуйста, введите чувствительное слово"
    },
    "disable": "Чувствительное слово отключено",
    "edit": "Редактировать чувствительное слово",
    "editFailed": "Ошибка обновления чувствительного слова",
    "editSuccess": "Чувствительное слово обновлено успешно",
    "emptyState": "Пока нет чувствительных слов. Нажмите 'Добавить чувствительное слово' в правом верхнем углу для начала настройки.",
    "enable": "Чувствительное слово включено",
    "refreshCache": "Обновить кэш",
    "refreshCacheFailed": "Не удалось обновить кэш",
    "refreshCacheSuccess": "Кэш успешно обновлен, загружено {count} чувствительных слов",
    "section": {
      "description": "Запросы, заблокированные чувствительными словами, не будут пересылаться и не будут тарифицироваться. Поддерживает частичное совпадение, точное совпадение и регулярные выражения.",
      "title": "Список чувствительных слов"
    },
    "table": {
      "actions": "Действия",
      "createdAt": "Создано",
      "description": "Описание",
      "matchType": "Тип совпадения",
      "matchTypeContains": "Частичное",
      "matchTypeExact": "Точное",
      "matchTypeRegex": "Регулярное",
      "status": "Статус",
      "word": "Чувствительное слово"
    },
    "title": "Управление чувствительными словами",
    "toggleFailed": "Ошибка переключения",
    "toggleFailedError": "Ошибка переключения:"
  },
  "notifications": {
    "title": "Push-уведомления",
    "description": "Настройка push-уведомлений робота WeChat Work",
    "global": {
      "title": "Главный переключатель уведомлений",
      "description": "Включить или отключить все функции push-уведомлений",
      "enable": "Включить push-уведомления"
    },
    "circuitBreaker": {
      "title": "Оповещение о размыкателе цепи",
      "description": "Отправить оповещение немедленно при полном размыкании провайдера",
      "enable": "Включить оповещение о размыкателе цепи",
      "webhook": "Webhook URL",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=...",
      "test": "Тест подключения"
    },
    "dailyLeaderboard": {
      "title": "Ежедневный рейтинг потребления пользователей",
      "description": "Ежедневная отправка рейтинга топ N пользователей по потреблению",
      "enable": "Включить ежедневный рейтинг",
      "webhook": "Webhook URL",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=...",
      "time": "Время отправки",
      "timePlaceholder": "09:00",
      "timeError": "Ошибка формата времени, должен быть HH:mm",
      "topN": "Показать топ N",
      "test": "Тест подключения"
    },
    "costAlert": {
      "title": "Оповещение о расходах",
      "description": "Триггер оповещения при превышении порога квоты потребления пользователя/провайдера",
      "enable": "Включить оповещение о расходах",
      "webhook": "Webhook URL",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=...",
      "threshold": "Порог оповещения",
      "thresholdLabel": "Порог оповещения: {percent}%",
      "thresholdHelp": "Оповещение при достижении {percent}% квоты",
      "interval": "Интервал проверки (минуты)",
      "test": "Тест подключения"
    },
    "form": {
      "save": "Сохранить настройки",
      "saving": "Сохранение...",
      "loading": "Загрузка...",
      "success": "Настройки уведомлений сохранены и задачи перепланированы",
      "saveFailed": "Ошибка сохранения",
      "saveError": "Не удалось сохранить настройки",
      "loadError": "Не удалось загрузить настройки уведомлений",
      "webhookRequired": "Сначала заполните Webhook URL",
      "testSuccess": "Тестовое сообщение отправлено, проверьте WeChat Work",
      "testFailed": "Тест не пройден",
      "testFailedRetry": "Тест не пройден, попробуйте снова",
      "testError": "Ошибка тестирования подключения",
      "testNoResult": "Тест пройден, но результат не возвращен"
    }
  },
  "errors": {
    "saveSuccess": "Сохранение успешно",
    "saveFailed": "Ошибка сохранения",
    "saveFailed_error": "Не удалось сохранить настройки",
    "addSuccess": "Добавление успешно",
    "addFailed": "Не удалось добавить провайдера",
    "editSuccess": "Обновление успешно",
    "editFailed": "Не удалось обновить провайдера",
    "deleteSuccess": "Удаление успешно",
    "deleteFailed": "Не удалось удалить провайдера",
    "syncSuccess": "Синхронизация успешна",
    "syncFailed": "Ошибка синхронизации",
    "testFailed": "Тест не пройден",
    "testFailedRetry": "Тест не пройден, попробуйте снова",
    "loadFailed": "Не удалось загрузить настройки уведомлений",
    "unknownError": "Во время операции произошло исключение"
  }
}
