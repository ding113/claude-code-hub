{
  "clientVersions": {
    "description": "クライアントバージョン要件を管理し、ユーザーが最新の安定版を使用していることを確認します。VSCodeとCLIは個別に管理されます。",
    "empty": {
      "description": "过去 7 天内没有活跃用户使用可识别的客户端",
      "title": "暂无客户端数据"
    },
    "features": {
      "activeWindow": "活跃窗口：",
      "activeWindowDesc": "仅统计过去 7 天内有请求的用户",
      "autoDetect": "系统会自动检测每种客户端的最新稳定版本（GA 版本）",
      "blockOldVersion": "使用旧版本的用户将收到 HTTP 400 错误，无法继续使用服务",
      "errorMessage": "错误提示中包含当前版本和需要升级的版本号",
      "gaRule": "判定规则：",
      "gaRuleDesc": "当某个版本被 1 个以上用户使用时，视为 GA 版本",
      "recommendation": "推荐做法：",
      "recommendationDesc": "先观察下方的版本分布，确认新版本稳定后再启用。",
      "title": "功能说明",
      "whatHappens": "启用后会发生什么："
    },
    "section": {
      "distribution": {
        "description": "显示过去 7 天内活跃用户的客户端版本信息。每种客户端类型独立统计 GA 版本。",
        "title": "客户端版本分布"
      },
      "settings": {
        "description": "启用后，系统将自动检测客户端版本并拦截旧版本用户的请求。",
        "title": "升级提醒设置"
      }
    },
    "table": {
      "currentGA": "当前 GA 版本：",
      "internalType": "内部类型：",
      "lastActive": "最后活跃时间",
      "latest": "最新",
      "needsUpgrade": "需升级",
      "noUsers": "暂无用户数据",
      "status": "状态",
      "unknown": "未知",
      "user": "用户",
      "usersCount": "{count} 位用户",
      "version": "当前版本"
    },
    "title": "クライアント更新リマインダー",
    "toggle": {
      "description": "有効にすると、システムはクライアントバージョンを自動的に検出し、古いバージョンをブロックします。",
      "disableSuccess": "クライアントバージョンチェックが無効になりました",
      "enable": "クライアントバージョンチェックを有効にする",
      "enableSuccess": "クライアントバージョンチェックが有効になりました",
      "toggleFailed": "トグルに失敗しました"
    }
  },
  "common": {
    "cancel": "キャンセル",
    "completed": "完了",
    "confirm": "確認",
    "copied": "キーをクリップボードにコピーしました",
    "copy": "コピー",
    "copyFailed": "コピーに失敗しました",
    "create": "作成",
    "creating": "作成中...",
    "delete": "削除",
    "disabled": "無効",
    "edit": "編集",
    "empty": "結果が見つかりません",
    "enabled": "有効",
    "error": "不明なエラー",
    "failed": "失敗",
    "loading": "読み込み中...",
    "none": "なし（このバージョンを使用しているユーザーなし）",
    "refresh": "更新",
    "reset": "リセット",
    "save": "保存",
    "saving": "保存中...",
    "submit": "送信",
    "success": "成功",
    "test": "テスト",
    "testing": "テスト中...",
    "unlimited": "無制限",
    "unlimited_desc": "無制限",
    "update": "更新",
    "updating": "更新中..."
  },
  "config": {
    "autoCleanup": "ログ自動クリーンアップ",
    "autoCleanupDesc": "スケジュールに従って履歴ログを自動的にクリーンアップし、データベース容量を解放します。",
    "description": "システムの基本パラメータを管理し、サイト表示と統計動作に影響します。",
    "form": {
      "allowGlobalView": "グローバル統計表示を許可",
      "allowGlobalViewDesc": "管理者以外のユーザーがグローバル使用統計を表示できるようにします",
      "cleanupSchedule": "クリーンアップスケジュール",
      "cleanupScheduleDesc": "自動クリーンアップの実行スケジュールを選択します",
      "configUpdated": "システム設定が更新されました。ページが更新され、通貨表示の変更が適用されます。",
      "currencyDisplay": "通貨表示単位",
      "keepDays": "保持日数",
      "keepDaysDesc": "指定した日数より古いログをクリーンアップします",
      "saveFailed": "保存に失敗しました",
      "saveSuccess": "正常に保存されました",
      "siteTitle": "サイトタイトル",
      "siteTitlePlaceholder": "例：Claude Code Hub",
      "siteTitleRequired": "サイトタイトルは空にできません"
    },
    "siteSettings": "サイトパラメータ",
    "siteSettingsDesc": "サイトタイトル、通貨表示単位、ダッシュボード統計表示方針を設定します。",
    "title": "基本設定"
  },
  "data": {
    "cleanup": {
      "clean": "クリーンアップ",
      "cleaning": "クリーンアップ中...",
      "confirmDelete": "履歴ログをクリーンアップしてもよろしいですか？このアクションは取り消せません。",
      "description": "履歴ログを削除してストレージスペースを解放します。統計データは保持されます。",
      "failed": "クリーンアップに失敗しました",
      "preview": "{count}個のログレコードが削除されます",
      "success": "ログクリーンアップが完了しました",
      "title": "ログクリーンアップ"
    },
    "description": "データベースのバックアップと復元を管理し、完全なインポート/エクスポートとログクリーンアップをサポートします。",
    "export": {
      "description": "データベースをバックアップファイルとしてエクスポートして、データ移行または災害復旧に使用します。",
      "export": "データをエクスポート",
      "exporting": "エクスポート中...",
      "failed": "エクスポートに失敗しました",
      "success": "データが正常にエクスポートされました",
      "title": "データエクスポート"
    },
    "guide": {
      "backup": "セキュリティ推奨：インポート前に現在のデータベースをバックアップとしてエクスポートすることをお勧めします。",
      "cleanup": "ログクリーンアップ：履歴ログを物理的に削除します（取り消せません）。統計テーブルは保持されます。クリーンアップ前にデータベースバックアップをエクスポートすることをお勧めします。",
      "docker": "環境要件：Docker Composeデプロイメントが必要です。ローカル開発環境ではサポートされない可能性があります。",
      "format": "バックアップ形式：PostgreSQL custom format（.dump）を使用し、自動圧縮で異なるデータベースバージョンと互換性があります。",
      "merge": "統合モード：既存データを保持し、バックアップからのデータを挿入しようとします。主キーの競合がインポート失敗を引き起こす可能性があります。",
      "overwrite": "上書きモード：インポート前にすべての既存データを削除します。完全復元に最適です。",
      "title": "使用説明と注意事項"
    },
    "import": {
      "description": "バックアップファイルからデータベースを復元し、上書きと統合の2つのモードをサポートします。",
      "failed": "インポートに失敗しました",
      "import": "データをインポート",
      "importing": "インポート中...",
      "mode": "インポートモード",
      "modeMerge": "統合（既存データを保持）",
      "modeOverwrite": "上書き（インポート前にすべて削除）",
      "selectFile": "JSONファイルをクリックして選択、またはドラッグしてください",
      "success": "データが正常にインポートされました",
      "title": "データインポート"
    },
    "status": {
      "description": "現在のデータベース接続ステータスと基本情報を表示します。",
      "title": "データベースステータス"
    },
    "title": "データ管理"
  },
  "errors": {
    "addFailed": "プロバイダーの追加に失敗しました",
    "addSuccess": "正常に追加されました",
    "deleteFailed": "プロバイダーの削除に失敗しました",
    "deleteSuccess": "正常に削除されました",
    "editFailed": "プロバイダーの更新に失敗しました",
    "editSuccess": "正常に更新されました",
    "loadFailed": "通知設定の読み込みに失敗しました",
    "saveFailed": "保存に失敗しました",
    "saveFailed_error": "設定の保存に失敗しました",
    "saveSuccess": "正常に保存されました",
    "syncFailed": "同期に失敗しました",
    "syncSuccess": "同期成功",
    "testFailed": "テストに失敗しました",
    "testFailedRetry": "テストに失敗しました。もう一度試してください。",
    "unknownError": "操作中にエラーが発生しました"
  },
  "logs": {
    "description": "システムログレベルを動的に調整してロギング詳細度をリアルタイムで制御します。",
    "form": {
      "currentLevel": "現在のログレベル",
      "failed": "更新に失敗しました",
      "failedError": "更新に失敗しました：",
      "save": "設定を保存",
      "saving": "保存中...",
      "selectLevel": "ログレベルを選択",
      "success": "ログレベルが更新されました"
    },
    "subtitle": "ログレベルコントロール",
    "subtitleDesc": "変更はすぐに有効になります、再起動不要。本番環境でのトラブルシューティングに便利です。",
    "title": "ログ管理"
  },
  "nav": {
    "apiDocs": "APIドキュメント",
    "clientVersions": "クライアント更新リマインダー",
    "config": "設定",
    "data": "データ管理",
    "logs": "ログ",
    "notifications": "通知",
    "prices": "価格表",
    "providers": "プロバイダー",
    "sensitiveWords": "センシティブワード"
  },
  "notifications": {
    "circuitBreaker": {
      "description": "プロバイダーが完全にサーキットオープンしたときにアラートをすぐに送信します",
      "enable": "サーキットブレーカーアラートを有効にする",
      "test": "接続をテスト",
      "title": "サーキットブレーカーアラート",
      "webhook": "Webhook URL",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=..."
    },
    "costAlert": {
      "description": "ユーザー/プロバイダー支出がクォータ閾値を超えたときにアラートをトリガーします",
      "enable": "コストアラートを有効にする",
      "interval": "チェック間隔（分）",
      "test": "接続をテスト",
      "threshold": "アラート閾値",
      "thresholdHelp": "支出がクォータの{percent}%に達したときにアラート",
      "thresholdLabel": "アラート閾値：{percent}%",
      "title": "コストアラート",
      "webhook": "Webhook URL",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=..."
    },
    "dailyLeaderboard": {
      "description": "毎日スケジュール通りTop Nユーザー支出ランキングを送信します",
      "enable": "毎日のランキングを有効にする",
      "test": "接続をテスト",
      "time": "送信時間",
      "timeError": "時間形式エラー、HH:mmであるべきです",
      "timePlaceholder": "09:00",
      "title": "毎日のユーザー支出ランキング",
      "topN": "Top Nを表示",
      "webhook": "Webhook URL",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=..."
    },
    "description": "WeChat Workロボット通知の送信を設定します",
    "form": {
      "loadError": "通知設定の読み込みに失敗しました",
      "loading": "読み込み中...",
      "save": "設定を保存",
      "saveError": "設定の保存に失敗しました",
      "saveFailed": "保存に失敗しました",
      "saving": "保存中...",
      "success": "通知設定が保存され、タスクが再スケジュールされました",
      "testError": "接続テストに失敗しました",
      "testFailed": "テストに失敗しました",
      "testFailedRetry": "テストに失敗しました。もう一度試してください。",
      "testNoResult": "テストは成功しましたが結果が返されていません",
      "testSuccess": "テストメッセージが送信されました。WeChat Workを確認してください。",
      "webhookRequired": "まずWebhook URLを入力してください"
    },
    "global": {
      "description": "すべての通知機能を有効または無効にします",
      "enable": "通知を有効にする",
      "title": "通知マスタースイッチ"
    },
    "title": "通知"
  },
  "prices": {
    "description": "プラットフォーム基本設定とモデル価格を管理します",
    "dialog": {
      "description": "JSONファイルをアップロードして価格設定を更新します",
      "fileSizeLimit": "ファイルサイズは10MBを超えることはできません",
      "fileSizeLimitSmall": "ファイルサイズは10MB以下です",
      "getError": "キーの取得に失敗しました",
      "readError": "キーの取得に失敗しました",
      "selectFile": "JSONファイルをクリックして選択、またはドラッグしてください",
      "title": "モデル価格表を更新",
      "upload": "アップロード",
      "uploading": "アップロード中..."
    },
    "noData": "システムは組み込み価格表を持っています。上のボタンを使用して同期または更新してください。",
    "noModels": "モデル価格が見つかりません",
    "search": "搜索模型名称...",
    "subtitle": "モデル価格",
    "subtitleDesc": "AIモデルの価格設定を管理します",
    "sync": "同步 LiteLLM 价格",
    "syncFailed": "同期に失敗しました",
    "syncFailedError": "同期に失敗しました：",
    "syncNoResult": "価格表は更新されましたが結果が返されていません",
    "syncSuccess": "価格表が正常に更新されました",
    "syncing": "同期中...",
    "table": {
      "cachePrice": "缓存价格",
      "inputPrice": "入力価格 ($/M)",
      "model": "模型",
      "outputPrice": "出力価格 ($/M)",
      "updatedAt": "更新日時"
    },
    "title": "価格表",
    "upload": "更新模型价格表",
    "uploadFailed": "価格データの取得に失敗しました：",
    "uploadSuccess": "価格表が正常に更新されました"
  },
  "providers": {
    "add": "プロバイダーを追加",
    "addFailed": "プロバイダーの追加に失敗しました",
    "addProvider": "新增服务商",
    "addSuccess": "プロバイダーが正常に追加されました",
    "circuitBroken": "熔断中",
    "clone": "プロバイダーを複製",
    "cloneFailed": "コピーに失敗しました",
    "confirmDelete": "このプロバイダーを削除してもよろしいですか？",
    "confirmDeleteDesc": "确定要删除供应商 \"{name}\" 吗？此操作无法撤销。",
    "confirmDeleteProvider": "确认删除供应商？",
    "confirmDeleteProviderDesc": "确定要删除服务商\"{name}\"吗？此操作不可恢复。",
    "createProvider": "新增服务商",
    "delete": "プロバイダーを削除",
    "deleteFailed": "プロバイダーの削除に失敗しました",
    "deleteSuccess": "删除成功",
    "description": "APIサービスプロバイダーを設定し、可用性ステータスを維持します。",
    "disabledStatus": "禁用",
    "displayCount": "显示 {filtered} / {total} 个供应商",
    "edit": "プロバイダーを編集",
    "editFailed": "プロバイダーの更新に失敗しました",
    "editProvider": "编辑服务商",
    "enabledStatus": "启用",
    "form": {
      "addRedirect": "リダイレクトを追加",
      "allowAllModels": "✓ すべてのモデルを許可（推奨）",
      "apiAddress": "API 地址",
      "apiAddressPlaceholder": "例如: https://open.bigmodel.cn/api/anthropic",
      "apiAddressRequired": "API 地址 *",
      "apiKey": "APIキー",
      "apiKeyCurrent": "当前密钥:",
      "apiKeyLeaveEmpty": "（留空不更改）",
      "apiKeyLeaveEmptyDesc": "留空则不更改密钥",
      "apiKeyOptional": "現在のキーを保持する場合は空のままにしてください",
      "apiKeyPlaceholder": "APIキーを入力",
      "apiKeyRequired": "API 密钥 *",
      "baseUrl": "ベースURL",
      "baseUrlPlaceholder": "例：https://open.bigmodel.cn/api/anthropic",
      "baseUrlRequired": "プロバイダーURLを入力してください",
      "circuitBreakerConfig": "熔断器配置",
      "circuitBreakerConfigSummary": "{failureThreshold} 次失败 / {openDuration} 分钟熔断 / {successThreshold} 次成功恢复",
      "circuitBreakerDesc": "供应商连续失败时自动熔断，避免影响整体服务质量",
      "clearSearch": "検索をクリア",
      "codexInstructions": "Codexインストラクション方針",
      "codexInstructionsAuto": "自動（推奨）",
      "codexInstructionsDesc": "（スケジューリング方針を決定）",
      "codexInstructionsForce": "公式を強制",
      "codexInstructionsKeep": "元の値を保持",
      "codexStrategyAutoDesc": "透传客户端 instructions，400 错误时自动重试官方 prompt",
      "codexStrategyAutoLabel": "自动 (推荐)",
      "codexStrategyConfig": "Codex Instructions 策略",
      "codexStrategyConfigAuto": "自动 (推荐)",
      "codexStrategyConfigForce": "强制官方",
      "codexStrategyConfigKeep": "透传原样",
      "codexStrategyDesc": "控制如何处理 Codex 请求的 instructions 字段，影响与上游中转站的兼容性",
      "codexStrategyForceDesc": "始终使用官方 Codex CLI instructions（约 4000+ 字）",
      "codexStrategyForceLabel": "强制官方",
      "codexStrategyHint": "提示: 部分严格的 Codex 中转站（如 88code、foxcode）需要官方 instructions，选择\"自动\"或\"强制官方\"策略",
      "codexStrategyKeepDesc": "始终透传客户端 instructions，不自动重试（适用于宽松中转站）",
      "codexStrategyKeepLabel": "透传原样",
      "codexStrategySelect": "策略选择",
      "collapseAll": "折叠全部高级配置",
      "confirmAdd": "确认添加",
      "confirmAddPending": "添加中...",
      "confirmUpdate": "确认更新",
      "confirmUpdatePending": "更新中...",
      "costMultiplier": "コスト乗数",
      "costMultiplierDesc": "例：A（コスト1.0x）、C（コスト0.8x）",
      "costMultiplierLabel": "成本倍率",
      "costMultiplierPlaceholder": "1.0",
      "deleteButton": "删除",
      "enabled": "有効",
      "expandAll": "展开全部高级配置",
      "failureThreshold": "失败阈值（次）",
      "failureThresholdDesc": "连续失败多少次后触发熔断",
      "failureThresholdPlaceholder": "5",
      "filterAllProviders": "全部供应商",
      "filterByType": "タイプでフィルタ",
      "filterProvider": "筛选供应商类型",
      "group": "グループ",
      "groupPlaceholder": "例：premium, economy",
      "joinClaudePool": "加入 Claude 调度池",
      "joinClaudePoolDesc": "启用后，此供应商将与 Claude 类型供应商一起参与负载均衡调度",
      "joinClaudePoolHelp": "仅当模型重定向配置中存在映射到 claude-* 模型时可用。启用后，当用户请求 claude-* 模型时，此供应商也会参与调度选择。",
      "leaveEmpty": "無制限の場合は空のままにしてください",
      "limit0Means": "0は無制限を意味します",
      "limit5hLabel": "5小时消费上限 (USD)",
      "limitAmount5h": "5時間支出上限（USD）",
      "limitAmount5hDesc": "例：プロバイダーBが$10制限、$9.8消費済み",
      "limitAmountMonthly": "月間支出上限（USD）",
      "limitAmountWeekly": "週間支出上限（USD）",
      "limitConcurrent": "同時セッション数制限",
      "limitConcurrentDesc": "例：プロバイダーC制限2、現在アクティブセッション数：2",
      "limitConcurrentLabel": "并发 Session 上限",
      "limitMonthlyLabel": "月消费上限 (USD)",
      "limitPlaceholder0": "0 表示无限制",
      "limitPlaceholderUnlimited": "留空表示无限制",
      "limitWeeklyLabel": "周消费上限 (USD)",
      "modelRedirects": "モデルリダイレクト",
      "modelRedirectsAddNew": "添加新规则",
      "modelRedirectsCurrentRules": "当前规则 ({count})",
      "modelRedirectsDesc": "Claudeモデルリクエストを他のサポートされるモデルにリダイレクトします",
      "modelRedirectsEmpty": "暂无重定向规则。添加规则后，系统将自动重写请求中的模型名称。",
      "modelRedirectsExists": "模型 \"{model}\" 已存在重定向规则",
      "modelRedirectsLabel": "模型重定向配置",
      "modelRedirectsOptional": "(可选)",
      "modelRedirectsSourceModel": "用户请求的模型",
      "modelRedirectsSourcePlaceholder": "例如: claude-sonnet-4-5-20250929",
      "modelRedirectsSourceRequired": "源模型名称不能为空",
      "modelRedirectsTargetModel": "实际转发的模型",
      "modelRedirectsTargetPlaceholder": "例如: glm-4.6",
      "modelRedirectsTargetRequired": "目标模型名称不能为空",
      "modelWhitelist": "模型白名单",
      "modelWhitelistAllowAll": "允许所有 {type} 模型",
      "modelWhitelistAllowAllClause": "允许所有 Claude 模型",
      "modelWhitelistAllowAllOpenAI": "允许所有 OpenAI 模型",
      "modelWhitelistClear": "清空",
      "modelWhitelistDesc": "限制此供应商可以处理的模型。默认情况下，供应商可以处理该类型下的所有模型。",
      "modelWhitelistLabel": "允许的模型",
      "modelWhitelistLoading": "加载中...",
      "modelWhitelistManualAdd": "手动添加模型",
      "modelWhitelistManualDesc": "支持添加任意模型名称（不限于价格表中的模型）",
      "modelWhitelistManualPlaceholder": "输入模型名称（如 gpt-5-turbo）",
      "modelWhitelistNotFound": "未找到模型",
      "modelWhitelistSearchPlaceholder": "搜索模型名称...",
      "modelWhitelistSelectAll": "全选 ({count})",
      "modelWhitelistSelected": "已选择 {count} 个模型",
      "modelWhitelistSelectedOnly": "仅允许选中的 {count} 个模型。其他模型的请求不会调度到此供应商。",
      "name": "名前",
      "namePlaceholder": "プロバイダー名を入力",
      "openDuration": "熔断时长（分钟）",
      "openDurationDesc": "熔断后多久自动进入半开状态",
      "openDurationPlaceholder": "30",
      "priority": "優先度",
      "priorityDesc": "同じ優先度内では、コスト乗数の低い順でソートされます",
      "priorityLabel": "优先级",
      "priorityPlaceholder": "0",
      "providerGroupDesc": "供应商分组标签。只有用户的 providerGroup 与此值匹配时，该用户才能使用此供应商。示例：设置为 \"premium\" 表示只供 providerGroup=\"premium\" 的用户使用",
      "providerGroupLabel": "供应商分组",
      "providerGroupPlaceholder": "例如: premium, economy",
      "providerName": "服务商名称",
      "providerNamePlaceholder": "例如: 智谱",
      "providerNameRequired": "服务商名称 *",
      "providerType": "プロバイダータイプ",
      "providerTypeDesc": "选择供应商的 API 格式类型。",
      "providerTypeDisabledNote": "注：Gemini CLI 和 OpenAI Compatible 类型功能正在开发中，暂不可用",
      "proxy": "プロキシ",
      "proxyAddressFormats": "支持格式:",
      "proxyAddressLabel": "代理地址",
      "proxyAddressOptional": "(可选)",
      "proxyAddressPlaceholder": "例如: http://proxy.example.com:8080 或 socks5://127.0.0.1:1080",
      "proxyConfig": "代理配置",
      "proxyConfigDesc": "配置代理服务器以改善供应商连接性（支持 HTTP、HTTPS、SOCKS4、SOCKS5）",
      "proxyConfigNone": "未配置",
      "proxyConfigSummary": "已配置代理",
      "proxyConfigSummaryFallback": " (启用降级)",
      "proxyConfigured": "プロキシが設定されています",
      "proxyFallback": "プロキシ失敗時のフォールバック",
      "proxyFallbackDesc": "プロキシ失敗時に直接接続にフォールバックします",
      "proxyFallbackLabel": "代理失败时降级到直连",
      "proxyNotConfigured": "未設定",
      "proxyTestButton": "测试连接",
      "proxyTestDesc": "测试通过配置的代理访问供应商 URL（使用 HEAD 请求，不消耗额度）",
      "proxyTestFailed": "连接失败",
      "proxyTestFillUrl": "请先填写供应商 URL",
      "proxyTestLabel": "连接测试",
      "proxyTestNetworkError": "网络错误: {error}",
      "proxyTestProxyError": "代理错误: {error}",
      "proxyTestResponseTime": "响应时间: {time}",
      "proxyTestResultConnectionMethod": "连接方式: {via}",
      "proxyTestResultConnectionMethodDirect": "直连",
      "proxyTestResultConnectionMethodProxy": "代理",
      "proxyTestResultErrorType": "错误类型: {type}",
      "proxyTestResultFailed": "连接失败",
      "proxyTestResultMessage": "{message}",
      "proxyTestResultResponseTime": "响应时间: {time}ms",
      "proxyTestResultStatusCode": "状态码: {code}",
      "proxyTestResultSuccess": "连接成功 {via}",
      "proxyTestStatusCode": "| 状态码: {code}",
      "proxyTestSuccess": "连接成功",
      "proxyTestTesting": "测试中...",
      "proxyTestTimeout": "连接超时（5秒）。请检查：\n1. 代理服务器是否可访问\n2. 代理地址和端口是否正确\n3. 代理认证信息是否正确",
      "proxyTestViaDirect": "（直连）",
      "proxyTestViaProxy": "（通过代理）",
      "proxyUrl": "プロキシアドレス",
      "proxyUrlPlaceholder": "例：http://proxy.example.com:8080 または socks5://127.0.0.1:1080",
      "rateLimitConfig": "限流配置",
      "rateLimitConfigNone": "无限制",
      "rateLimitConfigSummary": "5h: ${fiveHour}, 周: ${weekly}, 月: ${monthly}, 并发: {concurrent}",
      "remark": "備考",
      "remarkPlaceholder": "オプション：説明を追加...",
      "removeRedirect": "リダイレクトを削除",
      "routingConfig": "路由配置",
      "routingConfigNone": "未配置",
      "routingConfigSummary": "{models} 个模型白名单, {redirects} 个重定向",
      "scheduleParams": "调度参数",
      "searchClear": "清除搜索",
      "searchPlaceholder": "プロバイダー名、URL、備考で検索...",
      "selectProviderType": "プロバイダータイプを選択",
      "sort": "プロバイダーをソート",
      "sortByCost": "コスト順",
      "sortByCreated": "作成日順（新-旧）",
      "sortByName": "名前順（A-Z）",
      "sortByPriority": "優先度順（高-低）",
      "sortByWeight": "重み順（高-低）",
      "sourceModel": "ソースモデル名",
      "sourceModelPlaceholder": "例：claude-sonnet-4-5-20250929",
      "sourceModelRequired": "ソースモデル名は空にできません",
      "successThreshold": "恢复阈值（次）",
      "successThresholdDesc": "半开状态下成功多少次后完全恢复",
      "successThresholdPlaceholder": "2",
      "targetModel": "ターゲットモデル名",
      "targetModelPlaceholder": "例：glm-4.6",
      "targetModelRequired": "ターゲットモデル名は空にできません",
      "testProxy": "接続をテスト",
      "testProxyFailed": "プロキシテストに失敗しました",
      "testProxyFailedError": "接続テスト失敗：",
      "testProxySuccess": "プロキシ接続成功",
      "validUrlRequired": "请输入有效的 API 地址",
      "websiteUrl": "供应商官网地址",
      "websiteUrlDesc": "供应商官网地址，用于快速跳转管理",
      "websiteUrlInvalid": "请输入有效的供应商官网地址",
      "websiteUrlPlaceholder": "https://example.com",
      "weight": "重み",
      "weightDesc": "加重ランダム確率。同じ優先度内では、重みが高いほど選択される確率が高くなります。",
      "weightLabel": "权重",
      "weightPlaceholder": "1"
    },
    "guide": {
      "after": "过滤后：",
      "before": "过滤前：",
      "bestPracticesConcurrent": "• 并发控制：根据供应商 API 限制设置 Session 并发数",
      "bestPracticesCost": "• 成本倍率：官方倍率为 1.0，自建服务可设置为 0.8-1.2",
      "bestPracticesLimit": "• 限额设置：根据预算设置 5 小时、7 天、30 天限额",
      "bestPracticesPriority": "• 优先级设置：核心供应商设为 0，备用供应商设为 1-3",
      "bestPracticesTitle": "最佳实践建议",
      "bestPracticesWeight": "• 权重配置：根据供应商容量设置权重（容量大 = 权重高）",
      "circuitBreaker": "サーキットブレーカーチェック",
      "circuitBreakerOpen": "Aはフィルタされました、残り：B、C、D",
      "circuitBreakerRecovery": "Aは60秒後に半開状態に自動復帰します",
      "circuitBreakerRecovery5h": "5時間スライディングウィンドウ後に自動復帰",
      "costOptimize": "2️⃣ 成本优化：同优先级内，成本倍率低的供应商有更高概率",
      "costSort": "コストベースのソートフォールバック",
      "costSortExample": "すべてのプロバイダー：A（default）、B（premium）、C（premium）、D（economy）",
      "costSortProb": "より安いCがより高い選択確率を持ちます",
      "costSortResult": "ソート後：C（0.8x）、A（1.0x）",
      "decision": "决策：",
      "group": "ユーザーグループフィルタリング",
      "groupDesc": "ユーザーがプロバイダーグループを指定した場合、システムはそのグループから優先的に選択します",
      "groupDowngrade": "警告をログに記録し、グローバルプロバイダープールから選択",
      "groupExample": "ユーザーはproviderGroup = 'premium'を設定しました",
      "groupFallback": "グループに利用可能なプロバイダーがない場合は、すべてのプロバイダーにフォールバック",
      "groupFiltered": "AとCのみから選択、BとDはフィルタされます",
      "groupUnavailable": "ユーザーグループ'vip'のすべてのプロバイダーが無効または制限超過です",
      "health": "ヘルスフィルタリング（サーキットブレーカー+レート制限）",
      "healthCheck": "Bが有効で健全かをチェック",
      "healthCheckAmountLimit": "支出制限超過をチェック（5時間、7日、30日）",
      "healthCheckAmountLimitExample": "プロバイダーB制限$10（5時間）、$9.8消費済み",
      "healthCheckCircuit": "プロバイダーA 5回失敗、サーキットブレーカー：オープン",
      "healthCheckConcurrent": "現在のアクティブセッション数がの制限をチェック",
      "healthCheckConcurrentExample": "プロバイダーC制限2、現在アクティブ2セッション",
      "healthFilter": "3️⃣ 健康过滤：自动跳过熔断或超限的供应商",
      "healthFiltered": "Bはフィルタされました（制限に接近）、残り：C、D",
      "healthFiltered2": "Cはフィルタされました（満杯）、残り：D",
      "history": "リクエスト履歴をチェック",
      "historyDesc": "このAPIキーが過去10秒間に使用したプロバイダーをクエリします",
      "priority": "優先度階層化",
      "priorityExample": "異なる優先度を持つ4つのプロバイダーが有効です",
      "priorityFirst": "1️⃣ 优先级优先：只从最高优先级（数值最小）的供应商中选择",
      "priorityResult": "最高優先度（0）にフィルタされました：A、C",
      "priorityStep": "システムは優先度でフィルタし、最高優先度のプロバイダーのみを選択します",
      "randomResult": "最終的にCがランダムに選択されました",
      "randomSelect": "加重ランダム",
      "reset": "サーキットブレーカーを手動リセット",
      "resetSuccess": "サーキットブレーカーがリセットされました",
      "scenario1Desc": "系统首先按优先级过滤，只从最高优先级的供应商中选择",
      "scenario1Step1": "初始状态",
      "scenario1Step1After": "筛选出最高优先级（0）的供应商：A, C",
      "scenario1Step1Before": "供应商 A (优先级 0), B (优先级 1), C (优先级 0), D (优先级 2)",
      "scenario1Step1Decision": "只从 A 和 C 中选择，B 和 D 被过滤",
      "scenario1Step1Desc": "有 4 个已启用的供应商，优先级各不相同",
      "scenario1Step2": "成本排序",
      "scenario1Step2After": "排序后：C (0.8x), A (1.0x)",
      "scenario1Step2Before": "A (成本 1.0x), C (成本 0.8x)",
      "scenario1Step2Decision": "成本更低的 C 有更高的被选中概率",
      "scenario1Step2Desc": "在同优先级内，按成本倍率从低到高排序",
      "scenario1Step3": "加权随机",
      "scenario1Step3After": "C 被选中概率 75%, A 被选中概率 25%",
      "scenario1Step3Before": "C (权重 3), A (权重 1)",
      "scenario1Step3Decision": "最终随机选择了 C",
      "scenario1Step3Desc": "使用权重进行随机选择，权重越高被选中概率越大",
      "scenario1Title": "优先级分层选择",
      "scenario2Desc": "如果用户指定了供应商组，系统会优先从该组中选择",
      "scenario2Step1": "检查用户分组",
      "scenario2Step1After": "过滤出 'premium' 组：B, C",
      "scenario2Step1Before": "所有供应商：A (default), B (premium), C (premium), D (economy)",
      "scenario2Step1Decision": "只从 B 和 C 中选择",
      "scenario2Step1Desc": "用户配置了 providerGroup = 'premium'",
      "scenario2Step2": "分组降级",
      "scenario2Step2After": "降级到所有启用的供应商：A, B, C, D",
      "scenario2Step2Before": "用户组 'vip' 内的供应商全部禁用或超限",
      "scenario2Step2Decision": "记录警告并从全局供应商池中选择",
      "scenario2Step2Desc": "如果用户组内没有可用供应商，降级到所有供应商",
      "scenario2Title": "用户分组过滤",
      "scenario3Desc": "系统自动过滤掉熔断或超限的供应商",
      "scenario3Step1": "熔断器检查",
      "scenario3Step1After": "A 被过滤，剩余：B, C, D",
      "scenario3Step1Before": "供应商 A 连续失败 5 次，熔断器状态：open",
      "scenario3Step1Decision": "A 在 60 秒后自动恢复到半开状态",
      "scenario3Step1Desc": "连续失败 5 次后熔断器打开，60 秒内不可用",
      "scenario3Step2": "金额限流",
      "scenario3Step2After": "B 被过滤（接近限额），剩余：C, D",
      "scenario3Step2Before": "供应商 B 的 5 小时限额 $10，已消耗 $9.8",
      "scenario3Step2Decision": "5 小时窗口滑动后自动恢复",
      "scenario3Step2Desc": "检查 5 小时、7 天、30 天的消费额度是否超限",
      "scenario3Step3": "并发 Session 限制",
      "scenario3Step3After": "C 被过滤（已满），剩余：D",
      "scenario3Step3Before": "供应商 C 并发限制 2，当前活跃 Session 数：2",
      "scenario3Step3Decision": "Session 过期（5 分钟）后自动释放",
      "scenario3Step3Desc": "检查当前活跃 Session 数是否超过配置的并发限制",
      "scenario3Title": "健康度过滤（熔断器 + 限流）",
      "scenario4Desc": "连续对话优先使用同一供应商，利用 Claude 的上下文缓存",
      "scenario4Step1": "检查历史请求",
      "scenario4Step1After": "检查 B 是否启用且健康",
      "scenario4Step1Before": "最近一次请求使用了供应商 B",
      "scenario4Step1Decision": "B 可用，直接复用，跳过随机选择",
      "scenario4Step1Desc": "查询该 API Key 最近 10 秒内使用的供应商",
      "scenario4Step2": "复用失效",
      "scenario4Step2After": "进入正常选择流程",
      "scenario4Step2Before": "上次使用的供应商 B 已被禁用或熔断",
      "scenario4Step2Decision": "从其他可用供应商中选择",
      "scenario4Step2Desc": "如果上次使用的供应商不可用，则重新选择",
      "scenario4Title": "会话复用机制",
      "scenariosTitle": "交互式场景演示",
      "session": "セッション再利用メカニズム",
      "sessionDesc": "前回使用したプロバイダーが利用できない場合は再選択します",
      "sessionExample": "最後のリクエストはプロバイダーBを使用しました",
      "sessionExpired": "セッションは期限切れ後に自動的に解放されます（5分）",
      "sessionFallback": "他の利用可能なプロバイダーから選択",
      "sessionLastUsed": "Bは利用可能、直接再利用、ランダム選択をスキップ",
      "sessionReuse": "4️⃣ 会话复用：连续对话复用同一供应商，节省上下文成本",
      "sessionUnavailable": "前回使用したプロバイダーBは無効またはサーキットオープン状態です",
      "step": "步骤",
      "title": "核心原则",
      "weight": "重みに基づく加重ランダム選択",
      "weightCalc": "Cは75％の選択確率、Aは25％",
      "weightExample": "C（重み3）、A（重み1）"
    },
    "keyLoading": "加载中...",
    "noProviders": "暂无服务商配置",
    "noProvidersDesc": "添加你的第一个 API 服务商",
    "notFound": "プロバイダーが見つかりません",
    "official": "官网",
    "resetCircuit": "熔断器已重置",
    "resetCircuitDesc": "供应商 \"{name}\" 的熔断状态已解除",
    "resetCircuitFailed": "重置熔断器失败",
    "scheduling": "スケジューリング戦略の詳細説明",
    "schedulingDesc": "プロバイダー選択の仕組み：優先度階層化、セッション再利用、ロードバランシング、フェイルオーバーを理解します",
    "searchNoResults": "未找到匹配的供应商",
    "searchResults": "找到 {count} 个匹配的供应商",
    "section": {
      "description": "配置上游服务商的金额限流和并发限制，留空表示无限制。",
      "title": "服务商管理"
    },
    "subtitle": "プロバイダー管理",
    "subtitleDesc": "上流プロバイダーの支出制限とセッション並行制限を設定します。空のままにすると無制限です。",
    "title": "プロバイダー管理",
    "todayUsage": "今日用量",
    "todayUsageCount": "{count} 次",
    "toggleFailed": "状态切换失败",
    "toggleSuccess": "供应商已{status}",
    "toggleSuccessDesc": "供应商 \"{name}\" 状态已更新",
    "updateFailed": "更新服务商失败",
    "viewKey": "查看完整 API Key",
    "viewKeyDesc": "请妥善保管，不要泄露给他人"
  },
  "sensitiveWords": {
    "add": "センシティブワードを追加",
    "addFailed": "センシティブワードの作成に失敗しました",
    "addSuccess": "センシティブワードが正常に作成されました",
    "cacheStats": "キャッシュ統計：部分一致({containsCount}) 完全一致({exactCount}) 正規表現({regexCount})",
    "confirmDelete": "センシティブワード「{word}」を削除してもよろしいですか？",
    "delete": "センシティブワードを削除",
    "deleteFailed": "削除に失敗しました",
    "deleteSuccess": "センシティブワードが正常に削除されました",
    "description": "センシティブコンテンツをブロックするためにセンシティブワードフィルタリングルールを設定します。",
    "dialog": {
      "addDescription": "センシティブワードフィルタリングルールを設定します。マッチしたリクエストはアップストリームに転送されません。",
      "addTitle": "センシティブワードを追加",
      "creating": "作成中...",
      "descriptionLabel": "説明",
      "descriptionPlaceholder": "オプション：説明を追加...",
      "editDescription": "センシティブワード設定を変更します。変更後、自動的にキャッシュがリフレッシュされます。",
      "editTitle": "センシティブワードを編集",
      "matchTypeContains": "部分一致 - テキストにこの単語が含まれている場合ブロック",
      "matchTypeExact": "完全一致 - 完全に一致する場合のみブロック",
      "matchTypeLabel": "マッチタイプ *",
      "matchTypeRegex": "正規表現 - 複雑なパターンマッチングをサポート",
      "saving": "保存中...",
      "wordLabel": "センシティブワード *",
      "wordPlaceholder": "センシティブワードを入力...",
      "wordRequired": "センシティブワードを入力してください"
    },
    "disable": "センシティブワードが無効になりました",
    "edit": "センシティブワードを編集",
    "editFailed": "センシティブワードの更新に失敗しました",
    "editSuccess": "センシティブワードが正常に更新されました",
    "emptyState": "センシティブワードがありません。右上の「センシティブワードを追加」をクリックして設定を開始してください。",
    "enable": "センシティブワードが有効になりました",
    "refreshCache": "キャッシュを更新",
    "refreshCacheFailed": "キャッシュのリフレッシュに失敗しました",
    "refreshCacheSuccess": "キャッシュのリフレッシュに成功しました。{count}個のセンシティブワードを読み込みました",
    "section": {
      "description": "センシティブワードによってブロックされたリクエストはアップストリームに転送されず、課金もされません。部分一致、完全一致、正規表現の3つのモードをサポートしています。",
      "title": "センシティブワードリスト"
    },
    "table": {
      "actions": "操作",
      "createdAt": "作成日時",
      "description": "説明",
      "matchType": "マッチタイプ",
      "matchTypeContains": "部分一致",
      "matchTypeExact": "完全一致",
      "matchTypeRegex": "正規表現",
      "status": "ステータス",
      "word": "センシティブワード"
    },
    "title": "センシティブワード管理",
    "toggleFailed": "トグルに失敗しました",
    "toggleFailedError": "トグルに失敗しました："
  }
}
